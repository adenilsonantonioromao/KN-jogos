<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Runner 3D - Monolithic</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #root {
            width: 100vw;
            height: 100vh;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        .score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00f2ff;
        }

        .menu-card {
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            border: 2px solid #ff0055;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(255, 0, 85, 0.4);
        }

        button {
            background: #ff0055;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
        }

        button:hover {
            background: #ff3377;
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0055;
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            background: linear-gradient(45deg, #ff0055, #00f2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
    </style>

    <!-- React 18 and Three.js dependencies via ESM -->
   <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber"
      }
    }
    </script>
    <!-- Babel standalone for JSX processing -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Stars } from '@react-three/drei';

        // Jogo Constants
        const OBSTACLE_SPEED = 0.35;
        const SPAWN_INTERVAL = 30; // frames
        const ROAD_WIDTH = 10;
        const PLAYER_Z = 5;

        function Player({ x }) {
            const mesh = useRef();
            
            useFrame(() => {
                if (mesh.current) {
                    mesh.current.position.x = THREE.MathUtils.lerp(
                        mesh.current.position.x,
                        x,
                        0.15
                    );
                }
            });

            return (
                <mesh ref={mesh} position={[0, 0.5, PLAYER_Z]}>
                    <boxGeometry args={[1, 1, 1]} />
                    <meshStandardMaterial 
                        emissive="#00f2ff" 
                        emissiveIntensity={2} 
                        color="#00f2ff" 
                    />
                    <pointLight color="#00f2ff" intensity={1} distance={5} />
                </mesh>
            );
        }

        function Obstacle({ data, onHit, playerX, onCollide }) {
            const mesh = useRef();
            
            useFrame(() => {
                if (mesh.current) {
                    mesh.current.position.z += OBSTACLE_SPEED;
                    
                    // Detec√ß√£o de colis√£o baseada em posi√ß√£o Z e X
                    const distZ = Math.abs(mesh.current.position.z - PLAYER_Z);
                    const distX = Math.abs(mesh.current.position.x - playerX);
                    
                    if (distZ < 1 && distX < 1.2) {
                        onCollide();
                    }

                    if (mesh.current.position.z > 10) {
                        onHit(data.id);
                    }
                }
            });

            return (
                <mesh ref={mesh} position={[data.x, 0.75, data.z]}>
                    <boxGeometry args={[1.5, 1.5, 1.5]} />
                    <meshStandardMaterial 
                        emissive="#ff0055" 
                        emissiveIntensity={1.5} 
                        color="#ff0055" 
                    />
                </mesh>
            );
        }

        function Road() {
            return (
                <group>
                    <gridHelper args={[100, 50, 0x444444, 0x222222]} position={[0, 0, 0]} />
                    <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.1, 0]}>
                        <planeGeometry args={[ROAD_WIDTH, 1000]} />
                        <meshStandardMaterial color="#050505" />
                    </mesh>
                </group>
            );
        }

        function Game({ gameState, setGameState, score, setScore }) {
            const [playerX, setPlayerX] = useState(0);
            const [obstacles, setObstacles] = useState([]);
            const frameCount = useRef(0);
            const scoreRef = useRef(0);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (gameState !== 'PLAYING') return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') setPlayerX(x => Math.max(x - 2, -4));
                    if (e.key === 'ArrowRight' || e.key === 'd') setPlayerX(x => Math.min(x + 2, 4));
                };

                const handleMouseMove = (e) => {
                    if (gameState !== 'PLAYING') return;
                    const normalizedX = (e.clientX / window.innerWidth) * ROAD_WIDTH - (ROAD_WIDTH / 2);
                    setPlayerX(Math.max(Math.min(normalizedX, 4), -4));
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('mousemove', handleMouseMove);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('mousemove', handleMouseMove);
                };
            }, [gameState]);

            useEffect(() => {
                if (gameState === 'PLAYING') {
                    setScore(0);
                    scoreRef.current = 0;
                    setObstacles([]);
                    setPlayerX(0);
                    frameCount.current = 0;
                }
            }, [gameState]);

            useFrame(() => {
                if (gameState !== 'PLAYING') return;

                frameCount.current++;
                scoreRef.current += 1;
                
                if (frameCount.current % 10 === 0) {
                    setScore(Math.floor(scoreRef.current / 10));
                }

                if (frameCount.current % SPAWN_INTERVAL === 0) {
                    const newX = (Math.random() - 0.5) * (ROAD_WIDTH - 2);
                    setObstacles(prev => [...prev, { id: Date.now() + Math.random(), x: newX, z: -50 }]);
                }
            });

            const triggerGameOver = () => {
                const finalScore = Math.floor(scoreRef.current / 10);
                setGameState('GAME_OVER');
                window.parent.postMessage({ type: 'GAME_OVER', score: finalScore }, '*');
            };

            const removeObstacle = (id) => {
                setObstacles(prev => prev.filter(o => o.id !== id));
            };

            return (
                <>
                    <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                    <ambientLight intensity={0.5} />
                    <pointLight position={[10, 10, 10]} intensity={1} />
                    
                    <Road />
                    
                    <Player x={playerX} />

                    {obstacles.map(obs => (
                        <Obstacle 
                            key={obs.id} 
                            data={obs}
                            playerX={playerX}
                            onHit={removeObstacle}
                            onCollide={triggerGameOver}
                        />
                    ))}

                    <fog attach="fog" args={['#050505', 5, 45]} />
                </>
            );
        }

        function App() {
            const [gameState, setGameState] = useState('START');
            const [score, setScore] = useState(0);

            const handleRestartRequest = () => {
                // Solicita permiss√£o ao site pai enviando o postMessage
                window.parent.postMessage({ type: 'RESTART_REQUEST' }, '*');
            };

            return (
                <div style={{ width: '100%', height: '100%' }}>
                    <Canvas camera={{ position: [0, 5, 15], fov: 60 }}>
                        <Game 
                            gameState={gameState} 
                            setGameState={setGameState} 
                            score={score}
                            setScore={setScore}
                        />
                    </Canvas>

                    <div className="ui-overlay">
                        {gameState === 'START' && (
                            <div className="menu-card">
                                <h1>NEON RUNNER</h1>
                                <p>Use A/D ou Mouse para desviar dos obst√°culos</p>
                                <button onClick={() => setGameState('PLAYING')}>Iniciar Jogo</button>
                            </div>
                        )}

                        {gameState === 'GAME_OVER' && (
                            <div className="menu-card">
                                <h1 style={{ color: '#ff0055' }}>FIM DE JOGO</h1>
                                <p>Sua pontua√ß√£o:</p>
                                <h2 style={{ fontSize: '48px', margin: '10px 0', textShadow: '0 0 10px #ff0055' }}>
                                    {score}
                                </h2>
                                <button onClick={handleRestartRequest}>JOGAR NOVAMENTE (-1 ü™ô)</button>
                            </div>
                        )}

                        {gameState === 'PLAYING' && (
                            <div className="score-board">
                                SCORE: {score}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
