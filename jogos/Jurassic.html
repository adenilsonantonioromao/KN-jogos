<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tank vs Dinos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&family=JetBrains+Mono:wght@400;700&display=swap');

        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #0f2d1a; 
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            touch-action: none;
        }
        .futuristic-border {
            border: 2px solid #00ff66;
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.5), inset 0 0 10px rgba(0, 255, 102, 0.3);
            background: rgba(0, 30, 15, 0.9);
            backdrop-filter: blur(4px);
        }
        .neon-text {
            color: #00ff66;
            text-shadow: 0 0 12px rgba(0, 255, 102, 0.9);
        }
        .header-font {
            font-family: 'Orbitron', sans-serif;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/genai@0.1.1" 
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        // Polyfill para evitar crash no navegador
        const process = { env: { API_KEY: '' } };

        // --- 1. CONTEÃšDO DE 'types.ts' ---
        
        var GameStatus;
        (function (GameStatus) {
            GameStatus["MENU"] = "MENU";
            GameStatus["BRIEFING"] = "BRIEFING";
            GameStatus["PLAYING"] = "PLAYING";
            GameStatus["GAME_OVER"] = "GAME_OVER";
        })(GameStatus || (GameStatus = {}));

        var DinoType;
        (function (DinoType) {
            DinoType["RAPTOR"] = "RAPTOR";
            DinoType["TREX"] = "TREX";
            DinoType["SPINO"] = "SPINO";
            DinoType["DILO"] = "DILOPHOSAURUS";
            DinoType["ANKYLO"] = "ANKYLOSAURUS";
            DinoType["TRICE"] = "TRICERATOPS";
            DinoType["PTERO"] = "PTERODACTYL";
            DinoType["COMPS"] = "COMPSOGNATHUS";
            DinoType["CARNO"] = "CARNOTAURUS";
            DinoType["STEGO"] = "STEGOSAURUS";
        })(DinoType || (DinoType = {}));

        // --- 2. CONTEÃšDO DE 'constants.ts' ---

        const WORLD_WIDTH = 3500;
        const WORLD_HEIGHT = 3500;
        const BASE_TANK_SPEED = 4.7;
        const TANK_ROTATION_SPEED = 0.055;
        const TANK_RADIUS = 28;
        const FIRE_COOLDOWN = 280;
        const OBJECTIVE_RADIUS = 80;
        const VISION_RADIUS = 550;

        const DINO_CONFIGS = {
            [DinoType.RAPTOR]: { hp: 50, speed: 2.99, damage: 12, radius: 22, color: '#00ff66', accent: '#004400', icon: 'ðŸ¦–', points: 5 },
            [DinoType.TREX]: { hp: 450, speed: 1.43, damage: 60, radius: 55, color: '#ff0033', accent: '#440000', icon: 'ðŸ¦–', points: 75 },
            [DinoType.SPINO]: { hp: 220, speed: 2.08, damage: 35, radius: 45, color: '#ffaa00', accent: '#663300', icon: 'ðŸŠ', points: 45 },
            [DinoType.DILO]: { hp: 70, speed: 2.47, damage: 20, radius: 25, color: '#cc00ff', accent: '#330044', icon: 'ðŸ¦Ž', points: 7 },
            [DinoType.ANKYLO]: { hp: 600, speed: 0.91, damage: 40, radius: 50, color: '#888888', accent: '#333333', icon: 'ðŸ¢', points: 30 },
            [DinoType.TRICE]: { hp: 350, speed: 1.82, damage: 45, radius: 48, color: '#3366ff', accent: '#001144', icon: 'ðŸ¦', points: 20 },
            [DinoType.PTERO]: { hp: 40, speed: 3.64, damage: 10, radius: 20, color: '#00ffff', accent: '#004444', icon: 'ðŸ¦…', points: 6 },
            [DinoType.COMPS]: { hp: 20, speed: 4.16, damage: 5, radius: 15, color: '#ffff00', accent: '#444400', icon: 'ðŸ', points: 2 },
            [DinoType.CARNO]: { hp: 200, speed: 2.73, damage: 30, radius: 35, color: '#ff6600', accent: '#442200', icon: 'ðŸ†', points: 18 },
            [DinoType.STEGO]: { hp: 400, speed: 1.17, damage: 25, radius: 46, color: '#00cc00', accent: '#003300', icon: 'ðŸŒ³', points: 25 }
        };

        const INITIAL_BRIEFING = "Comandante, os bio-predadores romperam o cerco. O setor estÃ¡ saturado. Mantenha os sistemas de mira ativos e siga para o ponto de extraÃ§Ã£o sinalizado no radar. Boa sorte.";

        const WAR_EFFORT_UPGRADES = [
            { id: 'armor', name: 'Blindagem de TitÃ¢nio', description: '+35 HP MÃ¡ximo', icon: 'ðŸ›¡ï¸' },
            { id: 'engine', name: 'Propulsores de Ãons', description: '+25% Velocidade TÃ¡tica', icon: 'âš™ï¸' },
            { id: 'fire_rate', name: 'Sincronizador de Disparo', description: '-30% Tempo de Recarga', icon: 'âš¡' },
            { id: 'damage', name: 'Cargas de Plasma', description: '+40% Poder de Fogo', icon: 'ðŸ’¥' },
            { id: 'vision', name: 'Sensor de Calor', description: '+30% Alcance de VisÃ£o', icon: 'ðŸ‘ï¸' },
            { id: 'radar', name: 'Radar de Longa DistÃ¢ncia', description: 'Minimapa Ampliado', icon: 'ðŸ“¡' },
            { id: 'shield', name: 'Campo de ForÃ§a', description: 'ReduÃ§Ã£o de Dano Recebido', icon: 'ðŸ’ ' },
            { id: 'auto_repair', name: 'Nanobots de Reparo', description: 'RecuperaÃ§Ã£o Gradual de Vida', icon: 'ðŸ”§' },
            { id: 'piercing', name: 'MuniÃ§Ã£o Atravessante', description: 'Tiros Perfuram Inimigos', icon: 'ðŸŽ¯' },
            { id: 'multishot', name: 'CanhÃ£o Duplo', description: 'Chance de Disparo Duplo', icon: 'â˜„ï¸' }
        ];

        // --- 3. CONTEÃšDO DE 'services/geminiService.ts' ---
        
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

        async function getMissionBriefing(wave, score, targetDino) {
            try {
                const response = await ai.models.generateContent({
                    model: 'gemini-1.5-flash', // Ajustado para modelo compatÃ­vel
                    contents: [{ role: 'user', parts: [{ text: `You are a military commander in a sci-fi world. A pilot is at wave ${wave} with score ${score}. The primary threat detected is the ${targetDino}. Write a 2-sentence mission briefing. Be intense, atmospheric, and mention how the ${targetDino} is behaving in the sector.` }] }],
                });
                return response.text ? response.text() : "Hold the line, pilot. They're coming from the brush. Do not let them breach the perimeter.";
            } catch (error) {
                console.error("Gemini briefing failed:", error);
                return `Intelligence reports a massive concentration of ${targetDino} units. Lock and load, it's going to be a long night.`;
            }
        }

        // --- 4. CONTEÃšDO DE 'components/GameCanvas.tsx' ---

        const GameCanvas = ({ status, onGameOver, onWaveComplete, onScoreUpdate, initialScore, currentWave, upgrades }) => {
            const canvasRef = useRef(null);
            const grassPatternRef = useRef(null);
            const [keys, setKeys] = useState(new Set());
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [isMouseDown, setIsMouseDown] = useState(false);
            const [activeSpecies, setActiveSpecies] = useState(new Set());

            const upgradeEffects = useMemo(() => ({
                speedBoost: upgrades.includes('engine') ? 1.25 : 1.0,
                damageBoost: upgrades.includes('damage') ? 1.4 : 1.0,
                fireRateBoost: upgrades.includes('fire_rate') ? 0.7 : 1.0,
                armorBoost: upgrades.includes('armor') ? 35 : 0,
                visionBoost: upgrades.includes('vision') ? 1.3 : 1.0,
                shieldBoost: upgrades.includes('shield') ? 0.75 : 1.0,
                autoRepair: upgrades.includes('auto_repair') ? 0.05 : 0
            }), [upgrades]);

            const speedModifier = useMemo(() => (1.0 + (initialScore / 10000) + (currentWave * 0.05)) * upgradeEffects.speedBoost, [initialScore, currentWave, upgradeEffects.speedBoost]);

            const tankRef = useRef({
                id: 'player',
                pos: { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 },
                radius: TANK_RADIUS,
                rotation: 0,
                turretRotation: 0,
                hp: 100,
                maxHp: 100,
                speed: BASE_TANK_SPEED,
                score: Math.floor(initialScore),
                ammo: 100,
                lastShot: 0,
            });

            const objectivePosRef = useRef({ x: 0, y: 0, isDiscovered: false });
            const obstaclesRef = useRef([]);
            const dinosRef = useRef([]);
            const projectilesRef = useRef([]);
            const bloodParticlesRef = useRef([]);
            const cameraRef = useRef({ x: 0, y: 0 });
            const frameIdRef = useRef(0);
            const minimapSize = 160;
            const minimapScale = minimapSize / WORLD_WIDTH;

            useEffect(() => {
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 128; patternCanvas.height = 128;
                const pctx = patternCanvas.getContext('2d');
                if (pctx) {
                    pctx.fillStyle = '#7de69d';
                    pctx.fillRect(0, 0, 128, 128);
                    for (let i = 0; i < 300; i++) {
                        pctx.fillStyle = ['#bbf7d0', '#4ade80', '#22c55e'][Math.floor(Math.random() * 3)];
                        pctx.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
                    }
                    const ctx = document.createElement('canvas').getContext('2d');
                    if (ctx) grassPatternRef.current = ctx.createPattern(patternCanvas, 'repeat');
                }
            }, []);

            const checkCollision = useCallback((x, y, radius, obstacles, buffer = 0) => {
                const totalRadius = radius + buffer;
                for (const ob of obstacles) {
                    const closestX = Math.max(ob.pos.x, Math.min(x, ob.pos.x + ob.width));
                    const closestY = Math.max(ob.pos.y, Math.min(y, ob.pos.y + ob.height));
                    const dist = Math.hypot(x - closestX, y - closestY);
                    if (dist < totalRadius) return true;
                }
                return false;
            }, []);

            useEffect(() => {
                if (status === GameStatus.PLAYING) {
                    const tank = tankRef.current;
                    tank.maxHp = 100 + upgradeEffects.armorBoost;
                    tank.hp = tank.maxHp;
                    tank.pos = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 };

                    const obstacles = [];
                    for (let i = 0; i < 10; i++) {
                        const w = 150 + Math.random() * 200, h = 150 + Math.random() * 200;
                        const pos = { x: 500 + Math.random() * (WORLD_WIDTH - 1000), y: 500 + Math.random() * (WORLD_HEIGHT - 1000) };
                        if (Math.hypot(pos.x - WORLD_WIDTH/2, pos.y - WORLD_HEIGHT/2) > 500) {
                            obstacles.push({ pos, width: w, height: h, type: 'WALL', isDiscovered: true });
                        }
                    }
                    obstaclesRef.current = obstacles;

                    const margin = 200;
                    const cornerPositions = [
                        { x: margin, y: margin },
                        { x: WORLD_WIDTH - margin, y: margin },
                        { x: margin, y: WORLD_HEIGHT - margin },
                        { x: WORLD_WIDTH - margin, y: WORLD_HEIGHT - margin }
                    ];
                    objectivePosRef.current = { ...cornerPositions[Math.floor(Math.random() * 4)], isDiscovered: true };

                    const types = Object.keys(DINO_CONFIGS);
                    const newDinos = [];
                    let remainingDinos = Math.max(80, currentWave * 20);
                    
                    while (remainingDinos > 0) {
                        const type = types[Math.floor(Math.random() * Math.min(types.length, 2 + currentWave))];
                        const config = DINO_CONFIGS[type];
                        
                        const isPackDino = config.hp <= 70;
                        const packSize = isPackDino ? Math.min(remainingDinos, 2 + Math.floor(Math.random() * 4)) : 1;
                        
                        let centerPos = { x: 0, y: 0 };
                        let validSpot = false;
                        let attempts = 0;

                        while (!validSpot && attempts < 50) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 800 + Math.random() * 2200;
                            centerPos = { 
                                x: Math.max(100, Math.min(WORLD_WIDTH - 100, tank.pos.x + Math.cos(angle) * dist)),
                                y: Math.max(100, Math.min(WORLD_HEIGHT - 100, tank.pos.y + Math.sin(angle) * dist))
                            };
                            if (!checkCollision(centerPos.x, centerPos.y, 120, obstacles, 20)) validSpot = true;
                            attempts++;
                        }

                        if (validSpot) {
                            for (let j = 0; j < packSize; j++) {
                                const offsetAngle = (Math.PI * 2 / packSize) * j;
                                const offsetDist = packSize > 1 ? 60 : 0;
                                const dPos = {
                                    x: centerPos.x + Math.cos(offsetAngle) * offsetDist,
                                    y: centerPos.y + Math.sin(offsetAngle) * offsetDist
                                };
                                
                                newDinos.push({
                                    id: Math.random().toString(36), type, pos: dPos, radius: config.radius, rotation: 0,
                                    hp: config.hp + currentWave * 15, maxHp: config.hp + currentWave * 15,
                                    speed: config.speed, damage: config.damage, lastAttack: 0, color: config.color, 
                                    isActive: Math.random() < 0.4 
                                });
                            }
                        }
                        remainingDinos -= packSize;
                    }
                    dinosRef.current = newDinos;
                    bloodParticlesRef.current = [];
                }
            }, [status, currentWave, upgradeEffects.armorBoost, checkCollision]);

            const update = useCallback(() => {
                if (status !== GameStatus.PLAYING) return;
                const tank = tankRef.current;
                if (upgradeEffects.autoRepair > 0) tank.hp = Math.min(tank.maxHp, tank.hp + upgradeEffects.autoRepair);

                const curSpeed = tank.speed * speedModifier;
                let mx = 0, my = 0;
                if (keys.has('KeyW') || keys.has('ArrowUp')) { mx += Math.cos(tank.rotation) * curSpeed; my += Math.sin(tank.rotation) * curSpeed; }
                if (keys.has('KeyS') || keys.has('ArrowDown')) { mx -= Math.cos(tank.rotation) * curSpeed; my -= Math.sin(tank.rotation) * curSpeed; }
                if (keys.has('KeyA') || keys.has('ArrowLeft')) tank.rotation -= TANK_ROTATION_SPEED;
                if (keys.has('KeyD') || keys.has('ArrowRight')) tank.rotation += TANK_ROTATION_SPEED;

                const nx = Math.max(tank.radius, Math.min(WORLD_WIDTH - tank.radius, tank.pos.x + mx));
                const ny = Math.max(tank.radius, Math.min(WORLD_HEIGHT - tank.radius, tank.pos.y + my));
                if (!checkCollision(nx, ny, tank.radius, obstaclesRef.current)) { tank.pos.x = nx; tank.pos.y = ny; }

                const species = new Set();
                const curVision = VISION_RADIUS * upgradeEffects.visionBoost;
                dinosRef.current.forEach(d => {
                    if (d.hp <= 0) return;
                    const dist = Math.hypot(tank.pos.x - d.pos.x, tank.pos.y - d.pos.y);
                    if (dist < curVision + 150) d.isActive = true;
                    if (d.isActive) {
                        species.add(d.type);
                        const angle = Math.atan2(tank.pos.y - d.pos.y, tank.pos.x - d.pos.x);
                        d.rotation = angle;
                        const dnx = d.pos.x + Math.cos(angle) * d.speed * speedModifier;
                        const dny = d.pos.y + Math.sin(angle) * d.speed * speedModifier;
                        if (!checkCollision(dnx, dny, d.radius, obstaclesRef.current)) { d.pos.x = dnx; d.pos.y = dny; }
                        if (dist < tank.radius + d.radius && Date.now() - d.lastAttack > 800) {
                            tank.hp -= d.damage * upgradeEffects.shieldBoost;
                            d.lastAttack = Date.now();
                            if (tank.hp <= 0) onGameOver(tank.score);
                        }
                    }
                });
                setActiveSpecies(species);

                tank.turretRotation = Math.atan2(mousePos.y + cameraRef.current.y - tank.pos.y, mousePos.x + cameraRef.current.x - tank.pos.x);
                if (isMouseDown && Date.now() - tank.lastShot > FIRE_COOLDOWN * upgradeEffects.fireRateBoost) {
                    projectilesRef.current.push({
                        pos: { ...tank.pos }, velocity: { x: Math.cos(tank.turretRotation) * 22, y: Math.sin(tank.turretRotation) * 22 },
                        damage: 45 * upgradeEffects.damageBoost, life: 85
                    });
                    tank.lastShot = Date.now();
                }

                projectilesRef.current.forEach(p => {
                    p.pos.x += p.velocity.x; p.pos.y += p.velocity.y; p.life--;
                    dinosRef.current.forEach(d => {
                        if (d.hp > 0 && Math.hypot(p.pos.x - d.pos.x, p.pos.y - d.pos.y) < d.radius + 15) {
                            d.hp -= p.damage; d.isActive = true;
                            if (!upgrades.includes('piercing')) p.life = 0;
                            if (d.hp <= 0) {
                                const dinoPoints = DINO_CONFIGS[d.type]?.points || 3;
                                tank.score += Math.floor(dinoPoints);
                                onScoreUpdate(tank.score);
                                const particleCount = 10 + Math.floor(M
