<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tank vs Dinos: Elite Warfare</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #051a0f; 
            touch-action: none; 
            color: #ffffff;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            /* Remove pixelated para permitir vetores suaves, mas mantemos nitidez */
            image-rendering: high-quality; 
        }
        
        /* Efeito de Monitor CRT Militar */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 40;
        }
        .vignette {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,10,0.8) 100%);
            pointer-events: none;
            z-index: 41;
        }

        .futuristic-panel {
            background: rgba(6, 20, 10, 0.95);
            border: 1px solid #34d399;
            box-shadow: 0 0 15px rgba(52, 211, 153, 0.2), inset 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
        }
        
        .digital-clock {
            font-family: 'Orbitron', sans-serif;
            background-color: #001100;
            border: 2px solid #1a4d2e;
            color: #33ff33;
            text-shadow: 0 0 5px #33ff33;
            letter-spacing: 2px;
        }

        .header-font { font-family: 'Orbitron', sans-serif; }
        
        /* Scrollbar customizada para o menu */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #001100; }
        ::-webkit-scrollbar-thumb { background: #34d399; border-radius: 3px; }

        @keyframes alert-pulse {
            0%, 100% { color: #33ff33; text-shadow: 0 0 5px #33ff33; border-color: #1a4d2e; }
            50% { color: #ff3333; text-shadow: 0 0 10px #ff0000; border-color: #ff0000; }
        }
        .critical-time {
            animation: alert-pulse 0.8s infinite;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/genai@1.34.0"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        const process = { env: { API_KEY: '' } };

        // --- 1. TYPES & CONSTANTS ---
        
        const GameStatus = { MENU: 'MENU', BRIEFING: 'BRIEFING', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER' };

        const DinoType = {
          RAPTOR: 'RAPTOR', TREX: 'TREX', SPINO: 'SPINO', DILO: 'DILOPHOSAURUS',
          ANKYLO: 'ANKYLOSAURUS', TRICE: 'TRICERATOPS', PTERO: 'PTERODACTYL',
          COMPS: 'COMPSOGNATHUS', CARNO: 'CARNOTAURUS', STEGO: 'STEGOSAURUS'
        };

        const WORLD_WIDTH = 3500;
        const WORLD_HEIGHT = 3500;
        const BASE_TANK_SPEED = 4.7;
        const TANK_ROTATION_SPEED = 0.055;
        const TANK_RADIUS = 28;
        const FIRE_COOLDOWN = 280;
        const OBJECTIVE_RADIUS = 80;
        const VISION_RADIUS = 550;
        const WAVE_TIME_LIMIT = 60000;

        // Configura√ß√£o visual aprimorada para renderiza√ß√£o vetorial
        const DINO_CONFIGS = {
          [DinoType.RAPTOR]: { hp: 50, speed: 2.99, damage: 12, radius: 22, color: '#22c55e', accent: '#14532d', icon: 'ü¶ñ', points: 1, scale: 0.8, type: 'theropod' },
          [DinoType.TREX]: { hp: 450, speed: 1.43, damage: 60, radius: 55, color: '#ef4444', accent: '#7f1d1d', icon: 'ü¶ñ', points: 18, scale: 2.2, type: 'theropod' },
          [DinoType.SPINO]: { hp: 220, speed: 2.08, damage: 35, radius: 45, color: '#f97316', accent: '#7c2d12', icon: 'üêä', points: 11, scale: 1.8, type: 'spino' },
          [DinoType.DILO]: { hp: 70, speed: 2.47, damage: 20, radius: 25, color: '#a855f7', accent: '#581c87', icon: 'ü¶é', points: 1, scale: 0.9, type: 'theropod_frill' },
          [DinoType.ANKYLO]: { hp: 600, speed: 0.91, damage: 40, radius: 50, color: '#64748b', accent: '#1e293b', icon: 'üê¢', points: 7, scale: 1.6, type: 'ankylo' },
          [DinoType.TRICE]: { hp: 350, speed: 1.82, damage: 45, radius: 48, color: '#3b82f6', accent: '#1e3a8a', icon: 'ü¶è', points: 5, scale: 1.7, type: 'trice' },
          [DinoType.PTERO]: { hp: 40, speed: 3.64, damage: 10, radius: 20, color: '#06b6d4', accent: '#164e63', icon: 'ü¶Ö', points: 1, scale: 1.0, type: 'ptero' },
          [DinoType.COMPS]: { hp: 20, speed: 4.16, damage: 5, radius: 15, color: '#eab308', accent: '#713f12', icon: 'üêÅ', points: 1, scale: 0.5, type: 'theropod' },
          [DinoType.CARNO]: { hp: 200, speed: 2.73, damage: 30, radius: 35, color: '#f43f5e', accent: '#881337', icon: 'üêÜ', points: 4, scale: 1.4, type: 'theropod_horns' },
          [DinoType.STEGO]: { hp: 400, speed: 1.17, damage: 25, radius: 46, color: '#22c55e', accent: '#064e3b', icon: 'üå≥', points: 6, scale: 1.7, type: 'stego' }
        };

        const INITIAL_BRIEFING = "Comandante, os bio-predadores romperam o cerco. O setor est√° saturado. Mantenha os sistemas de mira ativos e siga para o ponto de extra√ß√£o sinalizado no radar. Boa sorte.";

        const WAR_EFFORT_UPGRADES = [
          { id: 'armor', name: 'Blindagem de Tit√¢nio', description: '+35 HP M√°ximo', icon: 'üõ°Ô∏è' },
          { id: 'engine', name: 'Propulsores de √çons', description: '+25% Velocidade T√°tica', icon: '‚öôÔ∏è' },
          { id: 'fire_rate', name: 'Sincronizador', description: '-30% Tempo de Recarga', icon: '‚ö°' },
          { id: 'damage', name: 'Cargas de Plasma', description: '+40% Poder de Fogo', icon: 'üí•' },
          { id: 'vision', name: 'Sensor de Calor', description: '+30% Alcance de Vis√£o', icon: 'üëÅÔ∏è' },
          { id: 'radar', name: 'Radar Ampliado', description: 'Minimapa T√°tico', icon: 'üì°' },
          { id: 'shield', name: 'Campo de For√ßa', description: 'Redu√ß√£o de Dano', icon: 'üí†' },
          { id: 'auto_repair', name: 'Nanobots', description: 'Regenera√ß√£o de Hull', icon: 'üîß' },
          { id: 'piercing', name: 'Muni√ß√£o AP', description: 'Tiros Perfurantes', icon: 'üéØ' },
          { id: 'multishot', name: 'Canh√£o Duplo', description: 'Disparo Simult√¢neo', icon: '‚òÑÔ∏è' }
        ];

        // --- 2. SERVICES ---
        async function getMissionBriefing(wave, score, targetDino) {
          try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
            const response = await ai.models.generateContent({
              model: 'gemini-1.5-flash',
              contents: [{ role: 'user', parts: [{ text: `Sci-fi military briefing. Wave ${wave}. Threat: ${targetDino}. 2 sentences. Intense.` }] }],
            });
            return response.text ? response.text() : "Mantenha a posi√ß√£o. Eles est√£o vindo de todas as dire√ß√µes.";
          } catch (error) {
            return `Relat√≥rios indicam concentra√ß√£o massiva de ${targetDino}. Prepare-se para combate intenso.`;
          }
        }

        // --- 3. GRAPHICS ENGINE (NEW) ---
        
        // Fun√ß√£o auxiliar para desenhar dinossauros complexos
        const drawComplexDino = (ctx, dino, config, frame) => {
            const scale = config.scale;
            const walkCycle = Math.sin(frame * 0.2) * 5;
            
            ctx.save();
            ctx.scale(scale, scale);
            
            // Sombra
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;

            // Corpo base
            ctx.fillStyle = config.color;
            
            if (config.type.includes('theropod') || config.type === 'spino') {
                // B√≠pede (T-Rex, Raptor, etc)
                
                // Cauda
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.quadraticCurveTo(-25 + walkCycle, 5, -40, 0);
                ctx.quadraticCurveTo(-25 + walkCycle, -5, -10, 0);
                ctx.fill();

                // Patas (animadas)
                ctx.fillStyle = config.accent;
                ctx.beginPath(); ctx.ellipse(5, 8 + walkCycle, 4, 8, 0, 0, Math.PI*2); ctx.fill(); // Dir
                ctx.beginPath(); ctx.ellipse(5, -8 - walkCycle, 4, 8, 0, 0, Math.PI*2); ctx.fill(); // Esq
                
                // Corpo
                ctx.fillStyle = config.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI*2);
                ctx.fill();

                // Espinha (Spino)
                if (config.type === 'spino') {
                    ctx.fillStyle = config.accent;
                    ctx.beginPath();
                    ctx.arc(0, 0, 14, Math.PI, 0);
                    ctx.fill();
                }

                // Cabe√ßa
                ctx.fillStyle = config.color;
                ctx.save();
                ctx.translate(18, 0);
                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 7, 0, 0, Math.PI*2);
                ctx.fill();
                
                // Detalhes da cabe√ßa
                if (config.type === 'theropod_horns') { // Carno
                    ctx.fillStyle = config.accent;
                    ctx.beginPath(); ctx.moveTo(2, -5); ctx.lineTo(8, -10); ctx.lineTo(6, -4); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(2, 5); ctx.lineTo(8, 10); ctx.lineTo(6, 4); ctx.fill();
                }
                if (config.type === 'theropod_frill') { // Dilo
                    ctx.fillStyle = config.accent;
                    ctx.beginPath(); ctx.arc(-2, 0, 10, -Math.PI/2, Math.PI/2); ctx.fill();
                }

                // Olhos
                ctx.fillStyle = '#fff';
                ctx.fillRect(4, -3, 2, 2);
                ctx.fillRect(4, 3, 2, 2);
                ctx.restore();

            } else if (config.type === 'trice' || config.type === 'stego' || config.type === 'ankylo') {
                // Quadr√∫pede
                
                // Patas
                ctx.fillStyle = config.accent;
                ctx.beginPath(); ctx.rect(-10 + walkCycle, -12, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(10 - walkCycle, -12, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(-10 - walkCycle, 6, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(10 + walkCycle, 6, 6, 6); ctx.fill();

                // Cauda
                ctx.fillStyle = config.color;
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(-40 + walkCycle, 0);
                ctx.lineWidth = 6;
                ctx.strokeStyle = config.color;
                ctx.stroke();
                
                // Clava (Ankylo) ou Espinhos (Stego) na cauda
                if (config.type === 'ankylo') {
                    ctx.fillStyle = config.accent;
                    ctx.beginPath(); ctx.arc(-42 + walkCycle, 0, 6, 0, Math.PI*2); ctx.fill();
                }

                // Corpo
                ctx.fillStyle = config.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, 22, 14, 0, 0, Math.PI*2);
                ctx.fill();

                // Placas (Stego) ou Carapa√ßa (Ankylo)
                if (config.type === 'stego') {
                    ctx.fillStyle = config.accent;
                    for(let i=-15; i<15; i+=8) {
                        ctx.beginPath(); ctx.moveTo(i, -10); ctx.lineTo(i+4, -22); ctx.lineTo(i+8, -10); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(i, 10); ctx.lineTo(i+4, 22); ctx.lineTo(i+8, 10); ctx.fill();
                    }
                }
                if (config.type === 'ankylo') {
                    ctx.fillStyle = config.accent;
                    ctx.beginPath(); ctx.rect(-10, -8, 20, 16); ctx.fill();
                }

                // Cabe√ßa
                ctx.fillStyle = config.color;
                ctx.save();
                ctx.translate(24, 0);
                
                if (config.type === 'trice') {
                    // Escudo
                    ctx.fillStyle = config.accent;
                    ctx.beginPath(); ctx.arc(-2, 0, 12, -Math.PI/2, Math.PI/2); ctx.fill();
                    // Chifres
                    ctx.fillStyle = '#eee';
                    ctx.beginPath(); ctx.moveTo(4, -4); ctx.lineTo(18, -8); ctx.lineTo(6, -2); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(4, 4); ctx.lineTo(18, 8); ctx.lineTo(6, 2); ctx.fill();
                }
                
                ctx.fillStyle = config.color;
                ctx.beginPath(); ctx.ellipse(0, 0, 10, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.restore();

            } else if (config.type === 'ptero') {
                // Voador
                const wingFlap = Math.sin(frame * 0.5) * 10;
                ctx.fillStyle = config.color;
                
                // Asas
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -30 + wingFlap);
                ctx.lineTo(20, -10);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 30 - wingFlap);
                ctx.lineTo(20, 10);
                ctx.fill();

                // Corpo
                ctx.beginPath(); ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI*2); ctx.fill();
                
                // Cabe√ßa
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, 0); ctx.lineWidth = 3; ctx.strokeStyle = config.accent; ctx.stroke();
            }

            ctx.restore();
        };

        // --- 4. GAME CANVAS ---
        
        const GameCanvas = ({ status, onGameOver, onWaveComplete, onScoreUpdate, initialScore, currentWave, upgrades }) => {
          const canvasRef = useRef(null);
          const grassPatternRef = useRef(null);
          const timerDisplayRef = useRef(null);
          
          const [keys, setKeys] = useState(new Set());
          const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
          const [isMouseDown, setIsMouseDown] = useState(false);
          const [activeSpecies, setActiveSpecies] = useState(new Set());

          const waveStartTimeRef = useRef(Date.now());
          const frameCountRef = useRef(0);
          
          const upgradeEffects = useMemo(() => ({
            speedBoost: upgrades.includes('engine') ? 1.25 : 1.0,
            damageBoost: upgrades.includes('damage') ? 1.4 : 1.0,
            fireRateBoost: upgrades.includes('fire_rate') ? 0.7 : 1.0,
            armorBoost: upgrades.includes('armor') ? 35 : 0,
            visionBoost: upgrades.includes('vision') ? 1.3 : 1.0,
            shieldBoost: upgrades.includes('shield') ? 0.75 : 1.0,
            autoRepair: upgrades.includes('auto_repair') ? 0.05 : 0
          }), [upgrades]);

          const speedModifier = useMemo(() => (1.0 + (initialScore / 10000) + (currentWave * 0.05)) * upgradeEffects.speedBoost, [initialScore, currentWave, upgradeEffects.speedBoost]);

          const tankRef = useRef({
            id: 'player',
            pos: { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 },
            radius: TANK_RADIUS,
            rotation: 0,
            turretRotation: 0,
            hp: 100,
            maxHp: 100,
            speed: BASE_TANK_SPEED,
            score: Math.floor(initialScore),
            ammo: 100,
            lastShot: 0,
          });

          const objectivePosRef = useRef({ x: 0, y: 0, isDiscovered: false });
          const obstaclesRef = useRef([]);
          const dinosRef = useRef([]);
          const projectilesRef = useRef([]);
          const bloodParticlesRef = useRef([]);
          const cameraRef = useRef({ x: 0, y: 0 });
          const frameIdRef = useRef(0);

          const minimapSize = 160;
          const minimapScale = minimapSize / WORLD_WIDTH;

          // Textura de ch√£o melhorada
          useEffect(() => {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 256; patternCanvas.height = 256;
            const pctx = patternCanvas.getContext('2d');
            if (pctx) {
              // Base escura
              pctx.fillStyle = '#0f2d1a';
              pctx.fillRect(0, 0, 256, 256);
              
              // Ru√≠do de terra
              for (let i = 0; i < 800; i++) {
                  pctx.fillStyle = Math.random() > 0.5 ? '#1a3d26' : '#0a1f12';
                  const s = Math.random() * 4;
                  pctx.fillRect(Math.random() * 256, Math.random() * 256, s, s);
              }
              // Grama
              for (let i = 0; i < 400; i++) {
                pctx.fillStyle = ['#225533', '#2d6640', '#1e442a'][Math.floor(Math.random() * 3)];
                pctx.beginPath();
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                pctx.moveTo(x, y);
                pctx.lineTo(x + 2, y - 4);
                pctx.lineTo(x + 4, y);
                pctx.fill();
              }
              const ctx = document.createElement('canvas').getContext('2d');
              if (ctx) grassPatternRef.current = ctx.createPattern(patternCanvas, 'repeat');
            }
          }, []);

          const checkCollision = useCallback((x, y, radius, obstacles, buffer = 0) => {
            const totalRadius = radius + buffer;
            for (const ob of obstacles) {
              const closestX = Math.max(ob.pos.x, Math.min(x, ob.pos.x + ob.width));
              const closestY = Math.max(ob.pos.y, Math.min(y, ob.pos.y + ob.height));
              const dist = Math.hypot(x - closestX, y - closestY);
              if (dist < totalRadius) return true;
            }
            return false;
          }, []);

          useEffect(() => {
            if (status === GameStatus.PLAYING) {
              waveStartTimeRef.current = Date.now();
              const tank = tankRef.current;
              tank.maxHp = 100 + upgradeEffects.armorBoost;
              tank.hp = tank.maxHp;
              tank.pos = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 };
              
              const obstacles = [];
              for (let i = 0; i < 12; i++) {
                const w = 150 + Math.random() * 250, h = 150 + Math.random() * 250;
                const pos = { x: 500 + Math.random() * (WORLD_WIDTH - 1000), y: 500 + Math.random() * (WORLD_HEIGHT - 1000) };
                if (Math.hypot(pos.x - WORLD_WIDTH/2, pos.y - WORLD_HEIGHT/2) > 600) {
                  obstacles.push({ pos, width: w, height: h, type: 'WALL', isDiscovered: true });
                }
              }
              obstaclesRef.current = obstacles;

              const margin = 250;
              const cornerPositions = [
                { x: margin, y: margin },
                { x: WORLD_WIDTH - margin, y: margin },
                { x: margin, y: WORLD_HEIGHT - margin },
                { x: WORLD_WIDTH - margin, y: WORLD_HEIGHT - margin }
              ];
              objectivePosRef.current = { ...cornerPositions[Math.floor(Math.random() * 4)], isDiscovered: true };

              const types = Object.keys(DINO_CONFIGS);
              const newDinos = [];
              let remainingDinos = Math.max(80, currentWave * 20);
              
              while (remainingDinos > 0) {
                const type = types[Math.floor(Math.random() * Math.min(types.length, 2 + currentWave))];
                const config = DINO_CONFIGS[type];
                const isPackDino = config.hp <= 70;
                const packSize = isPackDino ? Math.min(remainingDinos, 2 + Math.floor(Math.random() * 4)) : 1;
                
                let centerPos = { x: 0, y: 0 };
                let validSpot = false;
                let attempts = 0;

                while (!validSpot && attempts < 50) {
                  const angle = Math.random() * Math.PI * 2;
                  const dist = 900 + Math.random() * 2200;
                  centerPos = { 
                    x: Math.max(100, Math.min(WORLD_WIDTH - 100, tank.pos.x + Math.cos(angle) * dist)),
                    y: Math.max(100, Math.min(WORLD_HEIGHT - 100, tank.pos.y + Math.sin(angle) * dist))
                  };
                  if (!checkCollision(centerPos.x, centerPos.y, 120, obstacles, 20)) validSpot = true;
                  attempts++;
                }

                if (validSpot) {
                  for (let j = 0; j < packSize; j++) {
                    const offsetAngle = (Math.PI * 2 / packSize) * j;
                    const offsetDist = packSize > 1 ? 60 : 0;
                    const dPos = {
                      x: centerPos.x + Math.cos(offsetAngle) * offsetDist,
                      y: centerPos.y + Math.sin(offsetAngle) * offsetDist
                    };
                    newDinos.push({
                      id: Math.random().toString(36), type, pos: dPos, radius: config.radius, rotation: 0,
                      hp: config.hp + currentWave * 15, maxHp: config.hp + currentWave * 15,
                      speed: config.speed, damage: config.damage, lastAttack: 0, color: config.color, 
                      isActive: Math.random() < 0.4 
                    });
                  }
                }
                remainingDinos -= packSize;
              }
              dinosRef.current = newDinos;
              bloodParticlesRef.current = [];
            }
          }, [status, currentWave, upgradeEffects.armorBoost, checkCollision]);

          const update = useCallback(() => {
            if (status !== GameStatus.PLAYING) return;
            frameCountRef.current++;
            const tank = tankRef.current;

            // Timer Logic
            const timeElapsed = Date.now() - waveStartTimeRef.current;
            const timeLeft = Math.max(0, WAVE_TIME_LIMIT - timeElapsed);
            
            if (timerDisplayRef.current) {
                const seconds = Math.ceil(timeLeft / 1000);
                const ms = Math.floor((timeLeft % 1000) / 10);
                timerDisplayRef.current.innerText = `${seconds.toString().padStart(2, '0')}:${ms.toString().padStart(2, '0')}`;
                if (seconds <= 10) timerDisplayRef.current.parentElement.classList.add('critical-time');
                else timerDisplayRef.current.parentElement.classList.remove('critical-time');
            }

            if (timeLeft <= 0) { onGameOver(tank.score); return; }

            if (upgradeEffects.autoRepair > 0) tank.hp = Math.min(tank.maxHp, tank.hp + upgradeEffects.autoRepair);

            const curSpeed = tank.speed * speedModifier;
            let mx = 0, my = 0;
            if (keys.has('KeyW') || keys.has('ArrowUp')) { mx += Math.cos(tank.rotation) * curSpeed; my += Math.sin(tank.rotation) * curSpeed; }
            if (keys.has('KeyS') || keys.has('ArrowDown')) { mx -= Math.cos(tank.rotation) * curSpeed; my -= Math.sin(tank.rotation) * curSpeed; }
            if (keys.has('KeyA') || keys.has('ArrowLeft')) tank.rotation -= TANK_ROTATION_SPEED;
            if (keys.has('KeyD') || keys.has('ArrowRight')) tank.rotation += TANK_ROTATION_SPEED;

            const nx = Math.max(tank.radius, Math.min(WORLD_WIDTH - tank.radius, tank.pos.x + mx));
            const ny = Math.max(tank.radius, Math.min(WORLD_HEIGHT - tank.radius, tank.pos.y + my));
            if (!checkCollision(nx, ny, tank.radius, obstaclesRef.current)) { tank.pos.x = nx; tank.pos.y = ny; }

            const species = new Set();
            const curVision = VISION_RADIUS * upgradeEffects.visionBoost;
            dinosRef.current.forEach(d => {
              if (d.hp <= 0) return;
              const dist = Math.hypot(tank.pos.x - d.pos.x, tank.pos.y - d.pos.y);
              if (dist < curVision + 150) d.isActive = true;
              if (d.isActive) {
                species.add(d.type);
                const angle = Math.atan2(tank.pos.y - d.pos.y, tank.pos.x - d.pos.x);
                d.rotation = angle;
                const dnx = d.pos.x + Math.cos(angle) * d.speed * speedModifier;
                const dny = d.pos.y + Math.sin(angle) * d.speed * speedModifier;
                if (!checkCollision(dnx, dny, d.radius, obstaclesRef.current)) { d.pos.x = dnx; d.pos.y = dny; }
                if (dist < tank.radius + d.radius && Date.now() - d.lastAttack > 800) {
                  tank.hp -= d.damage * upgradeEffects.shieldBoost;
                  d.lastAttack = Date.now();
                  if (tank.hp <= 0) onGameOver(tank.score);
                }
              }
            });
            setActiveSpecies(species);

            tank.turretRotation = Math.atan2(mousePos.y + cameraRef.current.y - tank.pos.y, mousePos.x + cameraRef.current.x - tank.pos.x);
            if (isMouseDown && Date.now() - tank.lastShot > FIRE_COOLDOWN * upgradeEffects.fireRateBoost) {
              projectilesRef.current.push({
                pos: { ...tank.pos }, velocity: { x: Math.cos(tank.turretRotation) * 22, y: Math.sin(tank.turretRotation) * 22 },
                damage: 45 * upgradeEffects.damageBoost, life: 85
              });
              tank.lastShot = Date.now();
            }

            projectilesRef.current.forEach(p => {
              p.pos.x += p.velocity.x; p.pos.y += p.velocity.y; p.life--;
              dinosRef.current.forEach(d => {
                if (d.hp > 0 && Math.hypot(p.pos.x - d.pos.x, p.pos.y - d.pos.y) < d.radius + 15) {
                  d.hp -= p.damage; d.isActive = true;
                  if (!upgrades.includes('piercing')) p.life = 0;
                  if (d.hp <= 0) {
                    const dinoPoints = DINO_CONFIGS[d.type]?.points || 1;
                    tank.score += Math.floor(dinoPoints);
                    onScoreUpdate(tank.score);
                    for (let i = 0; i < 8; i++) {
                      bloodParticlesRef.current.push({
                        pos: { ...d.pos },
                        velocity: { x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 },
                        life: 180, maxLife: 180, size: 2 + Math.random() * 4, color: '#991111'
                      });
                    }
                  }
                }
              });
            });

            bloodParticlesRef.current.forEach(p => {
              p.pos.x += p.velocity.x; p.pos.y += p.velocity.y;
              p.velocity.x *= 0.97; p.velocity.y *= 0.97; p.life--;
            });

            projectilesRef.current = projectilesRef.current.filter(p => p.life > 0);
            dinosRef.current = dinosRef.current.filter(d => d.hp > 0);
            bloodParticlesRef.current = bloodParticlesRef.current.filter(p => p.life > 0);

            if (Math.hypot(tank.pos.x - objectivePosRef.current.x, tank.pos.y - objectivePosRef.current.y) < OBJECTIVE_RADIUS) {
              onWaveComplete(currentWave + 1);
            }

            if (canvasRef.current) {
              cameraRef.current.x = tank.pos.x - canvasRef.current.width / 2;
              cameraRef.current.y = tank.pos.y - canvasRef.current.height / 2;
            }
          }, [status, keys, mousePos, isMouseDown, currentWave, upgrades, upgradeEffects, speedModifier, onGameOver, onWaveComplete, onScoreUpdate, checkCollision]);

          const draw = useCallback((ctx) => {
            const cam = cameraRef.current, tank = tankRef.current;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            if (grassPatternRef.current) {
              ctx.save();
              ctx.translate(-cam.x, -cam.y);
              ctx.fillStyle = grassPatternRef.current;
              ctx.fillRect(cam.x, cam.y, ctx.canvas.width, ctx.canvas.height);
              ctx.restore();
            }

            // World Border
            ctx.save();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0000';
            ctx.strokeRect(0 - cam.x, 0 - cam.y, WORLD_WIDTH, WORLD_HEIGHT);
            ctx.restore();

            // Particles
            bloodParticlesRef.current.forEach(p => {
              ctx.fillStyle = p.color; ctx.globalAlpha = p.life / p.maxLife;
              ctx.beginPath(); ctx.arc(p.pos.x - cam.x, p.pos.y - cam.y, p.size/2, 0, Math.PI*2); ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Obstacles
            obstaclesRef.current.forEach(ob => {
              ctx.save();
              ctx.translate(ob.pos.x - cam.x, ob.pos.y - cam.y);
              ctx.fillStyle = '#1f2937';
              ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 15;
              ctx.fillRect(0, 0, ob.width, ob.height);
              
              // Detalhes do topo
              ctx.fillStyle = '#374151';
              ctx.fillRect(10, 10, ob.width-20, ob.height-20);
              
              ctx.strokeStyle = '#4b5563';
              ctx.lineWidth = 2;
              ctx.strokeRect(0, 0, ob.width, ob.height);
              ctx.restore();
            });

            // Objective
            const obj = objectivePosRef.current;
            ctx.save();
            ctx.translate(obj.x - cam.x, obj.y - cam.y);
            ctx.beginPath(); ctx.arc(0, 0, OBJECTIVE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(52, 211, 153, 0.2)'; ctx.fill();
            ctx.strokeStyle = '#34d399'; ctx.lineWidth = 4; ctx.setLineDash([15, 8]); ctx.stroke();
            // Portal effect
            ctx.beginPath(); ctx.arc(0, 0, OBJECTIVE_RADIUS * Math.abs(Math.sin(Date.now()/500)), 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(52, 211, 153, 0.5)'; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();

            // Dinos (New Render)
            dinosRef.current.forEach(d => {
              ctx.save();
              ctx.translate(d.pos.x - cam.x, d.pos.y - cam.y);
              ctx.rotate(d.rotation);
              drawComplexDino(ctx, d, DINO_CONFIGS[d.type], frameCountRef.current);
              ctx.restore();
            });

            // Tank (Enhanced)
            ctx.save();
            ctx.translate(tank.pos.x - cam.x, tank.pos.y - cam.y);
            
            // Sombra do tanque
            ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 15;

            // Esteiras
            ctx.save(); ctx.rotate(tank.rotation);
            ctx.fillStyle = '#111'; 
            ctx.fillRect(-tank.radius, -tank.radius*1.1, tank.radius*2.2, tank.radius*0.6); // Esq
            ctx.fillRect(-tank.radius, tank.radius*0.5, tank.radius*2.2, tank.radius*0.6); // Dir
            // Detalhes esteira
            ctx.fillStyle = '#333';
            for(let i=-tank.radius; i<tank.radius; i+=8) {
                ctx.fillRect(i, -tank.radius*1.1, 4, tank.radius*0.6);
                ctx.fillRect(i, tank.radius*0.5, 4, tank.radius*0.6);
            }
            
            // Corpo Principal
            ctx.fillStyle = '#064e3b'; // Verde escuro
            ctx.fillRect(-tank.radius*0.9, -tank.radius*0.8, tank.radius*1.8, tank.radius*1.6);
            ctx.strokeStyle = '#34d399'; ctx.lineWidth = 1;
            ctx.strokeRect(-tank.radius*0.9, -tank.radius*0.8, tank.radius*1.8, tank.radius*1.6);
            ctx.restore();
