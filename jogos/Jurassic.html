<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tank vs. Dino: Jurassic Conflict</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scanline {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            animation: scanline 4s linear infinite;
            z-index: 100;
        }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@google/genai": "https://esm.sh/@google/genai@1.34.0",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
        import ReactDOM from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        // --- CONSTANTS ---
        const WORLD_WIDTH = 3000;
        const WORLD_HEIGHT = 3000;
        const BASE_TANK_SPEED = 2.5;
        const TANK_ROTATION_SPEED = 0.04;
        const TANK_RADIUS = 25;
        const FIRE_COOLDOWN = 300;
        const OBJECTIVE_RADIUS = 60;
        const VISION_RADIUS = 450;

        const DINO_CONFIGS = {
          RAPTOR: { hp: 40, speed: 1.6, damage: 10, radius: 20, color: '#38b000', accent: '#004b23' },
          TREX: { hp: 250, speed: 0.6, damage: 40, radius: 45, color: '#9d0208', accent: '#370617' },
          SPINO: { hp: 140, speed: 1.0, damage: 25, radius: 35, color: '#ff9100', accent: '#ff6d00' }
        };

        const INITIAL_BRIEFING = "Comandante, fomos detectados. O terreno Ã© hostil e os predadores estÃ£o famintos. Use a vegetaÃ§Ã£o como referÃªncia e nÃ£o pare de se mover. A sobrevivÃªncia Ã© sua Ãºnica missÃ£o.";

        const WAR_EFFORT_UPGRADES = [
          { id: 'armor', name: 'Blindagem ReforÃ§ada', description: '+25 HP MÃ¡ximo e Reparo', icon: 'ðŸ›¡ï¸' },
          { id: 'engine', name: 'Motor Turbo', description: '+20% Velocidade de Movimento', icon: 'âš™ï¸' },
          { id: 'fire_rate', name: 'Carregador AutomÃ¡tico', description: '-25% Tempo de Recarga', icon: 'âš¡' },
          { id: 'damage', name: 'ProjÃ©teis de TungstÃªnio', description: '+30% Dano de CanhÃ£o', icon: 'ðŸ’¥' }
        ];

        // --- SERVICES ---
        async function getMissionBriefing(wave, score, targetDino) {
          try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
            const response = await ai.models.generateContent({
              model: 'gemini-3-flash-preview',
              contents: `You are a military commander in a sci-fi world. A pilot is at wave ${wave} with score ${score}. 
                         The primary threat detected is the ${targetDino}. 
                         Write a 2-sentence mission briefing in Portuguese. 
                         Be intense, atmospheric, and mention how the ${targetDino} is behaving in the sector.`,
            });
            return response.text || "Mantenha a posiÃ§Ã£o, piloto. Eles estÃ£o vindo pela mata. NÃ£o deixe que quebrem o perÃ­metro.";
          } catch (error) {
            console.error("Gemini briefing failed:", error);
            return `RelatÃ³rios de inteligÃªncia mostram uma concentraÃ§Ã£o massiva de unidades ${targetDino}. Prepare-se para o combate.`;
          }
        }

        // --- GAME CANVAS COMPONENT ---
        const GameCanvas = ({ status, onGameOver, onWaveComplete, onScoreUpdate, initialScore, currentWave, upgrades }) => {
          const canvasRef = useRef(null);
          const fogCanvasRef = useRef(document.createElement('canvas'));
          const [keys, setKeys] = useState(new Set());
          const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
          const [isMouseDown, setIsMouseDown] = useState(false);
          const leftJoyRef = useRef({ active: false, basePos: { x: 0, y: 0 }, currentPos: { x: 0, y: 0 }, identifier: null });
          const rightJoyRef = useRef({ active: false, basePos: { x: 0, y: 0 }, currentPos: { x: 0, y: 0 }, identifier: null });
          const [, setTick] = useState(0);

          const [score, setScore] = useState(initialScore);
          const [lastRepairTime, setLastRepairTime] = useState(0);
          
          const upgradeEffects = useMemo(() => ({
            speedBoost: upgrades.includes('engine') ? 1.2 : 1.0,
            damageBoost: upgrades.includes('damage') ? 1.3 : 1.0,
            fireRateBoost: upgrades.includes('fire_rate') ? 0.75 : 1.0,
            armorBoost: upgrades.includes('armor') ? 25 : 0
          }), [upgrades]);

          const speedModifier = useMemo(() => (0.8 + (score / 2000) + (currentWave * 0.04)) * upgradeEffects.speedBoost, [score, currentWave, upgradeEffects.speedBoost]);

          const tankRef = useRef({
            id: 'player', pos: { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 }, radius: TANK_RADIUS, rotation: 0,
            turretRotation: 0, hp: 100, maxHp: 100, speed: BASE_TANK_SPEED, score: initialScore, ammo: 100, lastShot: 0,
          });

          const objectivePosRef = useRef({ x: 100, y: 100, isDiscovered: false });
          const obstaclesRef = useRef([]);
          const dinosRef = useRef([]);
          const projectilesRef = useRef([]);
          const repairKitsRef = useRef([]);
          const explosionsRef = useRef([]);
          const treesRef = useRef([]);
          const cameraRef = useRef({ x: 0, y: 0 });
          const frameIdRef = useRef(0);

          const checkCollision = useCallback((x, y, radius, obstacles, buffer = 0) => {
            const totalRadius = radius + buffer;
            for (const ob of obstacles) {
              const closestX = Math.max(ob.pos.x, Math.min(x, ob.pos.x + ob.width));
              const closestY = Math.max(ob.pos.y, Math.min(y, ob.pos.y + ob.height));
              const distance = Math.hypot(x - closestX, y - closestY);
              if (distance < totalRadius) return true;
            }
            return false;
          }, []);

          const spawnDinos = useCallback((count, obstacles) => {
            const types = ['RAPTOR', 'SPINO', 'TREX'];
            const tank = tankRef.current;
            for (let i = 0; i < count; i++) {
              const type = types[Math.floor(Math.random() * (currentWave > 3 ? 3 : currentWave > 1 ? 2 : 1))];
              const config = DINO_CONFIGS[type];
              let spawnPos = { x: 0, y: 0 };
              let validPos = false;
              let attempts = 0;
              while (!validPos && attempts < 200) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 800 + Math.random() * 1500;
                spawnPos = { 
                  x: Math.max(config.radius + 50, Math.min(WORLD_WIDTH - (config.radius + 50), tank.pos.x + Math.cos(angle) * dist)), 
                  y: Math.max(config.radius + 50, Math.min(WORLD_HEIGHT - (config.radius + 50), tank.pos.y + Math.sin(angle) * dist)) 
                };
                if (!checkCollision(spawnPos.x, spawnPos.y, config.radius, obstacles, 60)) validPos = true;
                attempts++;
              }
              if (validPos) {
                dinosRef.current.push({
                  id: Math.random().toString(36), type, pos: spawnPos, radius: config.radius, rotation: 0,
                  hp: config.hp + (currentWave * 25), maxHp: config.hp + (currentWave * 25),
                  speed: config.speed, damage: config.damage, lastAttack: 0, color: config.color, isActive: false
                });
              }
            }
          }, [currentWave, checkCollision]);

          useEffect(() => {
            if (status === 'PLAYING') {
              const tank = tankRef.current;
              const initialMaxHp = 100 + upgradeEffects.armorBoost;
              tank.maxHp = initialMaxHp; tank.hp = initialMaxHp;
              tank.pos = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 }; tank.rotation = 0; tank.turretRotation = 0;
              dinosRef.current = []; explosionsRef.current = []; repairKitsRef.current = [];
              const obstacles = [];
              const types = ['BUNKER', 'RUINS', 'WALL'];
              for (let i = 0; i < 30; i++) {
                const width = 120 + Math.random() * 180;
                const height = 120 + Math.random() * 180;
                const pos = { x: 200 + Math.random() * (WORLD_WIDTH - 500), y: 200 + Math.random() * (WORLD_HEIGHT - 500) };
                if (Math.hypot(pos.x - WORLD_WIDTH/2, pos.y - WORLD_HEIGHT/2) > 450) {
                  obstacles.push({ pos, width, height, type: types[Math.floor(Math.random() * types.length)], isDiscovered: false });
                }
              }
              obstaclesRef.current = obstacles;
              const trees = [];
              for (let i = 0; i < 100; i++) {
                let treePos = { x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT };
                if (!checkCollision(treePos.x, treePos.y, 50, obstacles, 20)) {
                    trees.push({ pos: treePos, size: 35 + Math.random() * 45, rotation: Math.random() * Math.PI * 2 });
                }
              }
              treesRef.current = trees;
              const kits = [];
              const kitsToSpawn = 3 + Math.floor(currentWave / 2);
              for (let i = 0; i < kitsToSpawn; i++) {
                  const rx = 200 + Math.random() * (WORLD_WIDTH - 400);
                  const ry = 200 + Math.random() * (WORLD_HEIGHT - 400);
                  if (!checkCollision(rx, ry, 30, obstacles, 40)) repairKitsRef.current.push({ id: Math.random().toString(36), pos: { x: rx, y: ry }, isDiscovered: false });
              }
              let validObj = false;
              while (!validObj) {
                const x = 500 + Math.random() * (WORLD_WIDTH - 1000);
                const y = 500 + Math.random() * (WORLD_HEIGHT - 1000);
                if (!checkCollision(x, y, OBJECTIVE_RADIUS, obstacles, 100) && Math.hypot(x - tank.pos.x, y - tank.pos.y) > 1300) {
                  objectivePosRef.current = { x, y, isDiscovered: false };
                  validObj = true;
                }
              }
              spawnDinos(15 + Math.min(currentWave * 6, 60), obstacles);
            }
          }, [status, currentWave, upgradeEffects.armorBoost, spawnDinos, checkCollision]);

          useEffect(() => {
            const handleKeyDown = (e) => setKeys(prev => new Set(prev).add(e.code));
            const handleKeyUp = (e) => setKeys(prev => { const next = new Set(prev); next.delete(e.code); return next; });
            const handleMouseMove = (e) => {
              const rect = canvasRef.current.getBoundingClientRect();
              setMousePos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
            };
            const handleTouchStart = (e) => {
              e.preventDefault();
              const rect = canvasRef.current?.getBoundingClientRect();
              Array.from(e.changedTouches).forEach(touch => {
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                if (x < rect.width / 2 && !leftJoyRef.current.active) leftJoyRef.current = { active: true, basePos: { x, y }, currentPos: { x, y }, identifier: touch.identifier };
                else if (x >= rect.width / 2 && !rightJoyRef.current.active) rightJoyRef.current = { active: true, basePos: { x, y }, currentPos: { x, y }, identifier: touch.identifier };
              });
              setTick(t => t + 1);
            };
            const handleTouchMove = (e) => {
              e.preventDefault();
              const rect = canvasRef.current?.getBoundingClientRect();
              Array.from(e.changedTouches).forEach(touch => {
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                if (leftJoyRef.current.identifier === touch.identifier) leftJoyRef.current.currentPos = { x, y };
                if (rightJoyRef.current.identifier === touch.identifier) rightJoyRef.current.currentPos = { x, y };
              });
              setTick(t => t + 1);
            };
            const handleTouchEnd = (e) => {
              Array.from(e.changedTouches).forEach(touch => {
                if (leftJoyRef.current.identifier === touch.identifier) leftJoyRef.current = { active: false, basePos: { x: 0, y: 0 }, currentPos: { x: 0, y: 0 }, identifier: null };
                if (rightJoyRef.current.identifier === touch.identifier) rightJoyRef.current = { active: false, basePos: { x: 0, y: 0 }, currentPos: { x: 0, y: 0 }, identifier: null };
              });
              setTick(t => t + 1);
            };
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mousedown', () => setIsMouseDown(true)); window.addEventListener('mouseup', () => setIsMouseDown(false));
            const canvas = canvasRef.current;
            if (canvas) {
              canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
              canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
              canvas.addEventListener('touchend', handleTouchEnd); canvas.addEventListener('touchcancel', handleTouchEnd);
            }
            return () => {
              window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp);
              window.removeEventListener('mousemove', handleMouseMove);
              if (canvas) {
                canvas.removeEventListener('touchstart', handleTouchStart); canvas.removeEventListener('touchmove', handleTouchMove);
                canvas.removeEventListener('touchend', handleTouchEnd); canvas.removeEventListener('touchcancel', handleTouchEnd);
              }
            };
          }, []);

          const update = useCallback(() => {
            if (status !== 'PLAYING') return;
            const tank = tankRef.current; const obstacles = obstaclesRef.current;
            const currentTankSpeed = tank.speed * speedModifier;
            const currentFireCooldown = FIRE_COOLDOWN * upgradeEffects.fireRateBoost;
            const currentDamage = 35 * upgradeEffects.damageBoost;
            let moveX = 0, moveY = 0;
            if (leftJoyRef.current.active) {
              const dx = leftJoyRef.current.currentPos.x - leftJoyRef.current.basePos.x;
              const dy = leftJoyRef.current.currentPos.y - leftJoyRef.current.basePos.y;
              const dist = Math.hypot(dx, dy);
              if (dist > 5) {
                const angle = Math.atan2(dy, dx); const power = Math.min(dist, 60) / 60;
                moveX = Math.cos(angle) * currentTankSpeed * power; moveY = Math.sin(angle) * currentTankSpeed * power;
                let diff = angle - tank.rotation; while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
                tank.rotation += diff * 0.12;
              }
            } else {
              if (keys.has('KeyW') || keys.has('ArrowUp')) { moveX += Math.cos(tank.rotation) * currentTankSpeed; moveY += Math.sin(tank.rotation) * currentTankSpeed; }
              if (keys.has('KeyS') || keys.has('ArrowDown')) { moveX -= Math.cos(tank.rotation) * currentTankSpeed; moveY -= Math.sin(tank.rotation) * currentTankSpeed; }
              if (keys.has('KeyA') || keys.has('ArrowLeft')) tank.rotation -= TANK_ROTATION_SPEED;
              if (keys.has('KeyD') || keys.has('ArrowRight')) tank.rotation += TANK_ROTATION_SPEED;
            }
            const nextX = Math.max(tank.radius, Math.min(WORLD_WIDTH - tank.radius, tank.pos.x + moveX));
            const nextY = Math.max(tank.radius, Math.min(WORLD_HEIGHT - tank.radius, tank.pos.y + moveY));
            if (!checkCollision(nextX, nextY, tank.radius, obstacles)) { tank.pos.x = nextX; tank.pos.y = nextY; }
            else if (!checkCollision(nextX, tank.pos.y, tank.radius, obstacles)) tank.pos.x = nextX;
            else if (!checkCollision(tank.pos.x, nextY, tank.radius, obstacles)) tank.pos.y = nextY;
            obstacles.forEach(ob => { if (Math.hypot(tank.pos.x - (ob.pos.x + ob.width/2), tank.pos.y - (ob.pos.y + ob.height/2)) < VISION_RADIUS + 50) ob.isDiscovered = true; });
            repairKitsRef.current.forEach(kit => {
              const dist = Math.hypot(tank.pos.x - kit.pos.x, tank.pos.y - kit.pos.y);
              if (dist < VISION_RADIUS) kit.isDiscovered = true;
              if (dist < tank.radius + 20) { tank.hp = Math.min(tank.maxHp, tank.hp + 40); setLastRepairTime(Date.now()); kit.id = 'collected'; }
            });
            repairKitsRef.current = repairKitsRef.current.filter(k => k.id !== 'collected');
            const objDist = Math.hypot(tank.pos.x - objectivePosRef.current.x, tank.pos.y - objectivePosRef.current.y);
            if (objDist < VISION_RADIUS) objectivePosRef.current.isDiscovered = true;
            if (rightJoyRef.current.active) {
              const dx = rightJoyRef.current.currentPos.x - rightJoyRef.current.basePos.x;
              const dy = rightJoyRef.current.currentPos.y - rightJoyRef.current.basePos.y;
              if (Math.hypot(dx, dy) > 10) {
                tank.turretRotation = Math.atan2(dy, dx);
                if (Date.now() - tank.lastShot > currentFireCooldown) {
                  projectilesRef.current.push({ pos: { ...tank.pos }, velocity: { x: Math.cos(tank.turretRotation) * 15, y: Math.sin(tank.turretRotation) * 15 }, damage: currentDamage, life: 60 });
                  tank.lastShot = Date.now();
                }
              }
            } else {
              tank.turretRotation = Math.atan2(mousePos.y + cameraRef.current.y - tank.pos.y, mousePos.x + cameraRef.current.x - tank.pos.x);
              if (isMouseDown && Date.now() - tank.lastShot > currentFireCooldown) {
                projectilesRef.current.push({ pos: { ...tank.pos }, velocity: { x: Math.cos(tank.turretRotation) * 15, y: Math.sin(tank.turretRotation) * 15 }, damage: currentDamage, life: 60 });
                tank.lastShot = Date.now();
              }
            }
            dinosRef.current.forEach(dino => {
              const dToP = Math.hypot(tank.pos.x - dino.pos.x, tank.pos.y - dino.pos.y);
              if (!dino.isActive && dToP < VISION_RADIUS) dino.isActive = true;
              if (dino.isActive) {
                const angle = Math.atan2(tank.pos.y - dino.pos.y, tank.pos.x - dino.pos.x); dino.rotation = angle;
                const dNX = dino.pos.x + Math.cos(angle) * dino.speed * speedModifier;
                const dNY = dino.pos.y + Math.sin(angle) * dino.speed * speedModifier;
                if (!checkCollision(dNX, dNY, dino.radius, obstacles)) { dino.pos.x = dNX; dino.pos.y = dNY; }
                if (dToP < tank.radius + dino.radius && Date.now() - dino.lastAttack > 1000) {
                  tank.hp -= dino.damage; dino.lastAttack = Date.now();
                  if (tank.hp <= 0) onGameOver(tank.score);
                }
              }
              projectilesRef.current.forEach(p => {
                if (Math.hypot(p.pos.x - dino.pos.x, p.pos.y - dino.pos.y) < dino.radius) {
                  dino.hp -= p.damage; p.life = 0; dino.isActive = true;
                  if (dino.hp <= 0) {
                    tank.score += dino.type === 'TREX' ? 50 : dino.type === 'SPINO' ? 30 : 10;
                    setScore(tank.score); onScoreUpdate(tank.score);
                    explosionsRef.current.push({ pos: { ...dino.pos }, radius: dino.radius * 2.5, life: 25, maxLife: 25 });
                  }
                }
              });
            });
            projectilesRef.current.forEach(p => { p.pos.x += p.velocity.x; p.pos.y += p.velocity.y; p.life--; if (checkCollision(p.pos.x, p.pos.y, 4, obstacles)) p.life = 0; });
            explosionsRef.current.forEach(e => e.life--);
            projectilesRef.current = projectilesRef.current.filter(p => p.life > 0);
            dinosRef.current = dinosRef.current.filter(d => d.hp > 0);
            explosionsRef.current = explosionsRef.current.filter(e => e.life > 0);
            if (objDist < OBJECTIVE_RADIUS && status === 'PLAYING') onWaveComplete(currentWave + 1);
            if (canvasRef.current) { cameraRef.current.x = tank.pos.x - canvasRef.current.width / 2; cameraRef.current.y = tank.pos.y - canvasRef.current.height / 2; }
          }, [status, keys, mousePos, isMouseDown, currentWave, onGameOver, onWaveComplete, onScoreUpdate, speedModifier, upgradeEffects, checkCollision]);

          const draw = useCallback((ctx) => {
            const cam = cameraRef.current; const tank = tankRef.current; const obj = objectivePosRef.current;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.fillStyle = '#142a1e'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#1e3d2c'; for (let x = -cam.x % 120; x < ctx.canvas.width; x += 120) for (let y = -cam.y % 120; y < ctx.canvas.height; y += 120) ctx.fillRect(x + 20, y + 20, 4, 4);
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.1)'; ctx.lineWidth = 10; ctx.strokeRect(-cam.x, -cam.y, WORLD_WIDTH, WORLD_HEIGHT);
            obstaclesRef.current.forEach(ob => {
              ctx.save(); ctx.translate(ob.pos.x - cam.x, ob.pos.y - cam.y); ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(10, 10, ob.width, ob.height);
              ctx.fillStyle = ob.type === 'BUNKER' ? '#1e293b' : ob.type === 'RUINS' ? '#451a03' : '#171717'; ctx.fillRect(0, 0, ob.width, ob.height); ctx.restore();
            });
            repairKitsRef.current.forEach(kit => {
              ctx.save(); ctx.translate(kit.pos.x - cam.x, kit.pos.y - cam.y); ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 2); ctx.fillStyle = 'rgba(34, 197, 94, 0.2)'; ctx.fill();
              ctx.fillStyle = 'white'; ctx.fillRect(-12, -12, 24, 24); ctx.fillStyle = '#22c55e'; ctx.fillRect(-8, -2, 16, 4); ctx.fillRect(-2, -8, 4, 16); ctx.restore();
            });
            ctx.save(); ctx.translate(obj.x - cam.x, obj.y - cam.y); ctx.beginPath(); ctx.arc(0, 0, OBJECTIVE_RADIUS, 0, Math.PI * 2); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([10, 5]); ctx.stroke(); ctx.restore();
            treesRef.current.forEach(t => {
                ctx.save(); ctx.translate(t.pos.x - cam.x, t.pos.y - cam.y); ctx.fillStyle = '#2a1a10'; ctx.fillRect(-5, -5, 10, 10);
                ctx.fillStyle = '#064e3b'; ctx.beginPath(); ctx.moveTo(-t.size, t.size * 0.5); ctx.lineTo(0, -t.size); ctx.lineTo(t.size, t.size * 0.5); ctx.fill(); ctx.restore();
            });
            dinosRef.current.forEach(d => {
              const config = DINO_CONFIGS[d.type]; ctx.save(); ctx.translate(d.pos.x - cam.x, d.pos.y - cam.y); ctx.rotate(d.rotation); if (!d.isActive) ctx.globalAlpha = 0.4;
              ctx.fillStyle = config.color; ctx.fillRect(-d.radius, -d.radius*0.5, d.radius*1.8, d.radius); ctx.restore();
            });
            explosionsRef.current.forEach(e => {
              const alpha = e.life / e.maxLife; ctx.save(); ctx.translate(e.pos.x - cam.x, e.pos.y - cam.y); ctx.beginPath(); ctx.arc(0, 0, e.radius*(1-alpha*0.5), 0, Math.PI*2); ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.5})`; ctx.fill(); ctx.restore();
            });
            ctx.save(); ctx.translate(tank.pos.x - cam.x, tank.pos.y - cam.y);
            ctx.save(); ctx.rotate(Math.atan2(obj.y - tank.pos.y, obj.x - tank.pos.x)); ctx.translate(75, 0); ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-8, -8); ctx.lineTo(-8, 8); ctx.fillStyle = '#22c55e'; ctx.fill(); ctx.restore();
            ctx.save(); ctx.rotate(tank.rotation); ctx.fillStyle = '#1e293b'; ctx.fillRect(-tank.radius, -tank.radius * 0.8, tank.radius * 2, tank.radius * 1.6); ctx.restore();
            ctx.save(); ctx.rotate(tank.turretRotation); ctx.fillStyle = '#475569'; ctx.fillRect(-tank.radius * 0.5, -tank.radius * 0.5, tank.radius, tank.radius); ctx.fillStyle = '#94a3b8'; ctx.fillRect(0, -4, tank.radius * 1.8, 8); ctx.restore();
            ctx.restore();
            const fogCtx = fogCanvasRef.current.getContext('2d');
            if (fogCtx) {
              fogCanvasRef.current.width = ctx.canvas.width; fogCanvasRef.current.height = ctx.canvas.height;
              fogCtx.fillStyle = 'rgba(0, 0, 0, 0.92)'; fogCtx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              fogCtx.globalCompositeOperation = 'destination-out';
              const grad = fogCtx.createRadialGradient(tank.pos.x - cam.x, tank.pos.y - cam.y, 100, tank.pos.x - cam.x, tank.pos.y - cam.y, VISION_RADIUS);
              grad.addColorStop(0, 'white'); grad.addColorStop(1, 'transparent'); fogCtx.fillStyle = grad;
              fogCtx.beginPath(); fogCtx.arc(tank.pos.x - cam.x, tank.pos.y - cam.y, VISION_RADIUS, 0, Math.PI * 2); fogCtx.fill();
              fogCtx.globalCompositeOperation = 'source-over'; ctx.drawImage(fogCanvasRef.current, 0, 0);
            }
            ctx.fillStyle = '#fffb00'; projectilesRef.current.forEach(p => { ctx.beginPath(); ctx.arc(p.pos.x - cam.x, p.pos.y - cam.y, 4, 0, Math.PI * 2); ctx.fill(); });
            const hpR = Math.max(0, tank.hp / tank.maxHp); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(tank.pos.x - cam.x - 30, tank.pos.y - cam.y - tank.radius - 35, 60, 10);
            ctx.fillStyle = hpR > 0.5 ? '#22c55e' : hpR > 0.25 ? '#eab308' : '#ef4444'; ctx.fillRect(tank.pos.x - cam.x - 28, tank.pos.y - cam.y - tank.radius - 33, 56 * hpR, 6);
          }, [lastRepairTime]);

          const loop = useCallback(() => {
            if (canvasRef.current) {
              const ctx = canvasRef.current.getContext('2d');
              if (ctx) { update(); draw(ctx); }
            }
            frameIdRef.current = requestAnimationFrame(loop);
          }, [update, draw]);

          useEffect(() => {
            frameIdRef.current = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(frameIdRef.current);
          }, [loop]);

          useEffect(() => {
            const res = () => { if (canvasRef.current) { canvasRef.current.width = window.innerWidth; canvasRef.current.height = window.innerHeight; } };
            window.addEventListener('resize', res); res(); return () => window.removeEventListener('resize', res);
          }, []);

          return (
            <div className="relative w-full h-full overflow-hidden touch-none select-none">
              <canvas ref={canvasRef} className="block" />
              <div className="absolute top-2 left-2 md:top-4 md:left-4 p-3 md:p-5 bg-black/90 border border-green-500/30 rounded-xl backdrop-blur-xl z-50 shadow-2xl">
                <div className="flex justify-between gap-4 mb-2"><div className="text-green-500 font-mono text-[10px] uppercase">Integridade</div><div className="text-white font-mono text-[10px]">{score.toLocaleString()} PTS</div></div>
                <div className="w-40 md:w-80 h-3 bg-gray-900 rounded-full overflow-hidden border border-white/10 p-[1px]"><div className="h-full bg-gradient-to-r from-red-600 to-green-400" style={{ width: `${(tankRef.current.hp / tankRef.current.maxHp) * 100}%` }} /></div>
              </div>
            </div>
          );
        };

        // --- MAIN APP COMPONENT ---
        const App = () => {
          const [status, setStatus] = useState('MENU');
          const [score, setScore] = useState(0);
          const [wave, setWave] = useState(1);
          const [briefing, setBriefing] = useState(INITIAL_BRIEFING);
          const [isBriefingLoading, setIsBriefingLoading] = useState(false);
          const [targetDino, setTargetDino] = useState('RAPTOR');
          const [activeUpgrades, setActiveUpgrades] = useState([]);
          const [availableUpgrades, setAvailableUpgrades] = useState([]);
          const previewCanvasRef = useRef(null);

          const startGame = async () => {
            setScore(0); setWave(1); setActiveUpgrades([]);
            const firstTarget = ['RAPTOR', 'TREX', 'SPINO'][Math.floor(Math.random() * 3)];
            setTargetDino(firstTarget); setAvailableUpgrades(WAR_EFFORT_UPGRADES.sort(() => 0.5 - Math.random()).slice(0, 2));
            setStatus('BRIEFING');
          };

          const handleGameOver = (finalScore) => {
            setScore(finalScore);
            setStatus('GAME_OVER');
            window.parent.postMessage({ type: 'GAME_OVER', score: finalScore }, '*');
          };

          const handleWaveComplete = useCallback(async (nextWave) => {
            setStatus('BRIEFING'); setIsBriefingLoading(true); setWave(nextWave);
            const nextTarget = ['RAPTOR', 'TREX', 'SPINO'][Math.floor(Math.random() * 3)];
            setTargetDino(nextTarget);
            const newBriefing = await getMissionBriefing(nextWave, score, nextTarget);
            setBriefing(newBriefing); setAvailableUpgrades(WAR_EFFORT_UPGRADES.sort(() => 0.5 - Math.random()).slice(0, 2));
            setIsBriefingLoading(false);
          }, [score]);

          useEffect(() => {
            if (status === 'BRIEFING' && previewCanvasRef.current) {
              const ctx = previewCanvasRef.current.getContext('2d'); if (!ctx) return;
              let anim; const config = DINO_CONFIGS[targetDino];
              const render = () => {
                ctx.clearRect(0, 0, 200, 200); ctx.save(); ctx.translate(100, 100);
                ctx.rotate(Math.sin(Date.now() / 500) * 0.1); ctx.fillStyle = config.color;
                ctx.fillRect(-50, -25, 100, 50); ctx.restore(); anim = requestAnimationFrame(render);
              };
              render(); return () => cancelAnimationFrame(anim);
            }
          }, [status, targetDino]);

          return (
            <div className="relative w-full h-screen bg-[#020503] overflow-hidden">
              <div className="scanline"></div>
              {status === 'MENU' && (
                <div className="absolute inset-0 flex flex-col items-center justify-center z-50 p-6 bg-black/80 backdrop-blur-md">
                  <h1 className="text-5xl md:text-8xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-green-400 to-emerald-800 leading-none mb-10 text-center">JURASSIC<br/>CONFLICT</h1>
                  <button onClick={startGame} className="px-12 py-5 bg-green-600 hover:bg-green-500 text-white font-black text-xl uppercase rounded-lg shadow-xl active:scale-95 transition-all">Iniciar MissÃ£o</button>
                </div>
              )}
              {status === 'BRIEFING' && (
                <div className="absolute inset-0 flex flex-col items-center justify-center z-50 p-4 bg-black/95 backdrop-blur-xl">
                  <div className="w-full max-w-4xl grid md:grid-cols-2 gap-8 border-t-4 border-green-500 bg-black/50 p-8 rounded-b-xl shadow-2xl overflow-y-auto max-h-full">
                    <div className="space-y-6">
                      <h2 className="text-4xl md:text-5xl font-black text-white italic">FASE {wave}</h2>
                      <p className="text-green-100/80 font-mono text-sm leading-relaxed border-l-2 border-green-500/30 pl-4 py-2 italic">{isBriefingLoading ? "RECEBENDO BRIEFING..." : briefing}</p>
                      <div className="grid gap-3">
                        {availableUpgrades.map(u => (
                          <button key={u.id} onClick={() => { setActiveUpgrades(p => [...p, u.id]); setStatus('PLAYING'); }}
                                  className="flex items-center gap-4 p-4 bg-green-950/20 border border-green-500/30 hover:bg-green-600 transition-all rounded-lg text-left">
                            <span className="text-3xl">{u.icon}</span>
                            <div><div className="text-white font-bold uppercase text-sm">{u.name}</div><div className="text-green-500/70 text-xs font-mono">{u.description}</div></div>
                          </button>
                        ))}
                      </div>
                    </div>
                    <div className="flex flex-col items-center justify-center bg-green-500/5 p-8 rounded-2xl border border-green-500/10">
                      <canvas ref={previewCanvasRef} width="200" height="200" className="w-48 h-48 drop-shadow-2xl" />
                      <div className="text-4xl font-black text-white italic tracking-widest mt-4 uppercase">{targetDino}</div>
                    </div>
                  </div>
                </div>
              )}
              {status === 'GAME_OVER' && (
                <div className="absolute inset-0 flex flex-col items-center justify-center z-50 p-6 bg-red-950/90 backdrop-blur-2xl text-center">
                  <h2 className="text-6xl md:text-8xl font-black text-white italic leading-tight mb-8">MISSÃƒO<br/>FALHOU</h2>
                  <div className="text-3xl font-mono text-yellow-500 mb-8">{score.toLocaleString()} PTS</div>
                  <button 
                    onClick={() => window.parent.postMessage({ type: 'RESTART_REQUEST' }, '*')}
                    className="px-16 py-6 bg-white text-red-900 font-black text-2xl uppercase rounded-full hover:scale-110 active:scale-95 transition-all"
                  >
                    REINICIAR (-1 ðŸª™)
                  </button>
                </div>
              )}
              {(status === 'PLAYING' || status === 'BRIEFING' || status === 'GAME_OVER') && (
                <GameCanvas status={status} onGameOver={handleGameOver} onWaveComplete={handleWaveComplete} onScoreUpdate={setScore} initialScore={score} currentWave={wave} upgrades={activeUpgrades} />
              )}
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
