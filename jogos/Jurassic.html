<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tank vs Dinos: Elite Warfare</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #051a0f; 
            touch-action: none; 
            color: #ffffff;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            image-rendering: high-quality; 
        }
        
        /* Efeitos Visuais */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 40;
        }
        .vignette {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,20,10,0.8) 100%);
            pointer-events: none;
            z-index: 41;
        }

        .futuristic-panel {
            background: rgba(6, 20, 10, 0.95);
            border: 1px solid #34d399;
            box-shadow: 0 0 15px rgba(52, 211, 153, 0.2), inset 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
        }
        
        .digital-clock {
            font-family: 'Orbitron', sans-serif;
            background-color: #001100;
            border: 2px solid #1a4d2e;
            color: #33ff33;
            text-shadow: 0 0 5px #33ff33;
            letter-spacing: 2px;
        }

        .header-font { font-family: 'Orbitron', sans-serif; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #001100; }
        ::-webkit-scrollbar-thumb { background: #34d399; border-radius: 3px; }

        @keyframes alert-pulse {
            0%, 100% { color: #33ff33; text-shadow: 0 0 5px #33ff33; border-color: #1a4d2e; }
            50% { color: #ff3333; text-shadow: 0 0 10px #ff0000; border-color: #ff0000; }
        }
        .critical-time {
            animation: alert-pulse 0.8s infinite;
        }
    </style>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/genai@1.34.0",
        "react-dom/": "https://esm.sh/react-dom@^18.2/",
        "react/": "https://esm.sh/react@^18.2/"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        const process = { env: { API_KEY: '' } };

        // --- 1. TYPES & CONSTANTS ---
        
        const GameStatus = { MENU: 'MENU', BRIEFING: 'BRIEFING', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER' };

        const DinoType = {
          RAPTOR: 'RAPTOR', TREX: 'TREX', SPINO: 'SPINO', DILO: 'DILOPHOSAURUS',
          ANKYLO: 'ANKYLOSAURUS', TRICE: 'TRICERATOPS', PTERO: 'PTERODACTYL',
          COMPS: 'COMPSOGNATHUS', CARNO: 'CARNOTAURUS', STEGO: 'STEGOSAURUS'
        };

        const WORLD_WIDTH = 3500;
        const WORLD_HEIGHT = 3500;
        const BASE_TANK_SPEED = 4.7;
        const TANK_ROTATION_SPEED = 0.055;
        const TANK_RADIUS = 28;
        const FIRE_COOLDOWN = 280;
        const OBJECTIVE_RADIUS = 80;
        const VISION_RADIUS = 550;
        const WAVE_TIME_LIMIT = 60000;

        const DINO_CONFIGS = {
          [DinoType.RAPTOR]: { hp: 50, speed: 2.99, damage: 12, radius: 22, color: '#22c55e', accent: '#14532d', icon: 'ü¶ñ', points: 1, scale: 0.8, type: 'theropod' },
          [DinoType.TREX]: { hp: 450, speed: 1.43, damage: 60, radius: 55, color: '#ef4444', accent: '#7f1d1d', icon: 'ü¶ñ', points: 18, scale: 2.2, type: 'theropod' },
          [DinoType.SPINO]: { hp: 220, speed: 2.08, damage: 35, radius: 45, color: '#f97316', accent: '#7c2d12', icon: 'üêä', points: 11, scale: 1.8, type: 'spino' },
          [DinoType.DILO]: { hp: 70, speed: 2.47, damage: 20, radius: 25, color: '#a855f7', accent: '#581c87', icon: 'ü¶é', points: 1, scale: 0.9, type: 'theropod_frill' },
          [DinoType.ANKYLO]: { hp: 600, speed: 0.91, damage: 40, radius: 50, color: '#64748b', accent: '#1e293b', icon: 'üê¢', points: 7, scale: 1.6, type: 'ankylo' },
          [DinoType.TRICE]: { hp: 350, speed: 1.82, damage: 45, radius: 48, color: '#3b82f6', accent: '#1e3a8a', icon: 'ü¶è', points: 5, scale: 1.7, type: 'trice' },
          [DinoType.PTERO]: { hp: 40, speed: 3.64, damage: 10, radius: 20, color: '#06b6d4', accent: '#164e63', icon: 'ü¶Ö', points: 1, scale: 1.0, type: 'ptero' },
          [DinoType.COMPS]: { hp: 20, speed: 4.16, damage: 5, radius: 15, color: '#eab308', accent: '#713f12', icon: 'üêÅ', points: 1, scale: 0.5, type: 'theropod' },
          [DinoType.CARNO]: { hp: 200, speed: 2.73, damage: 30, radius: 35, color: '#f43f5e', accent: '#881337', icon: 'üêÜ', points: 4, scale: 1.4, type: 'theropod_horns' },
          [DinoType.STEGO]: { hp: 400, speed: 1.17, damage: 25, radius: 46, color: '#22c55e', accent: '#064e3b', icon: 'üå≥', points: 6, scale: 1.7, type: 'stego' }
        };

        const INITIAL_BRIEFING = "Comandante, os bio-predadores romperam o cerco. O setor est√° saturado. Mantenha os sistemas de mira ativos e siga para o ponto de extra√ß√£o sinalizado no radar. Boa sorte.";

        const WAR_EFFORT_UPGRADES = [
          { id: 'armor', name: 'Blindagem de Tit√¢nio', description: '+35 HP M√°ximo', icon: 'üõ°Ô∏è' },
          { id: 'engine', name: 'Propulsores de √çons', description: '+25% Velocidade T√°tica', icon: '‚öôÔ∏è' },
          { id: 'fire_rate', name: 'Sincronizador', description: '-30% Tempo de Recarga', icon: '‚ö°' },
          { id: 'damage', name: 'Cargas de Plasma', description: '+40% Poder de Fogo', icon: 'üí•' },
          { id: 'vision', name: 'Sensor de Calor', description: '+30% Alcance de Vis√£o', icon: 'üëÅÔ∏è' },
          { id: 'freezing', name: 'Muni√ß√£o Criog√™nica', description: 'Reduz Velocidade Inimiga (30%)', icon: '‚ùÑÔ∏è' }, // NOVO
          { id: 'shield', name: 'Campo de For√ßa', description: 'Redu√ß√£o de Dano', icon: 'üí†' },
          { id: 'auto_repair', name: 'Nanobots', description: 'Regenera√ß√£o de Hull', icon: 'üîß' },
          { id: 'piercing', name: 'Muni√ß√£o AP', description: 'Tiros Perfurantes', icon: 'üéØ' },
          { id: 'multishot', name: 'Canh√£o Duplo', description: 'Disparo Duplo Paralelo', icon: '‚òÑÔ∏è' } // ATUALIZADO
        ];

        // --- 2. SERVICES ---
        async function getMissionBriefing(wave, score, targetDino) {
          try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
            const response = await ai.models.generateContent({
              model: 'gemini-1.5-flash',
              contents: [{ role: 'user', parts: [{ text: `Sci-fi military briefing. Wave ${wave}. Threat: ${targetDino}. 2 sentences. Intense.` }] }],
            });
            return response.text ? response.text() : "Mantenha a posi√ß√£o. Eles est√£o vindo de todas as dire√ß√µes.";
          } catch (error) {
            return `Relat√≥rios indicam concentra√ß√£o massiva de ${targetDino}. Prepare-se para combate intenso.`;
          }
        }

        // --- 3. GRAPHICS ENGINE ---
        
        const drawComplexDino = (ctx, dino, config, frame) => {
            if (!config) return;
            const scale = config.scale || 1;
            const walkCycle = Math.sin(frame * 0.2) * 5;
            
            ctx.save();
            ctx.scale(scale, scale);
            
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;

            // Se estiver congelado, muda a cor base para azulado
            const baseColor = dino.isFrozen ? '#3b82f6' : config.color;
            const accentColor = dino.isFrozen ? '#1e3a8a' : config.accent;

            ctx.fillStyle = baseColor;
            
            if (config.type.includes('theropod') || config.type === 'spino') {
                // B√≠pede
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.quadraticCurveTo(-25 + walkCycle, 5, -40, 0);
                ctx.quadraticCurveTo(-25 + walkCycle, -5, -10, 0);
                ctx.fill();

                ctx.fillStyle = accentColor;
                ctx.beginPath(); ctx.ellipse(5, 8 + walkCycle, 4, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(5, -8 - walkCycle, 4, 8, 0, 0, Math.PI*2); ctx.fill();
                
                ctx.fillStyle = baseColor;
                ctx.beginPath(); ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI*2); ctx.fill();

                if (config.type === 'spino') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.arc(0, 0, 14, Math.PI, 0); ctx.fill();
                }

                ctx.fillStyle = baseColor;
                ctx.save();
                ctx.translate(18, 0);
                ctx.beginPath(); ctx.ellipse(0, 0, 10, 7, 0, 0, Math.PI*2); ctx.fill();
                
                if (config.type === 'theropod_horns') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.moveTo(2, -5); ctx.lineTo(8, -10); ctx.lineTo(6, -4); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(2, 5); ctx.lineTo(8, 10); ctx.lineTo(6, 4); ctx.fill();
                }
                if (config.type === 'theropod_frill') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.arc(-2, 0, 10, -Math.PI/2, Math.PI/2); ctx.fill();
                }

                ctx.fillStyle = '#fff';
                ctx.fillRect(4, -3, 2, 2);
                ctx.fillRect(4, 3, 2, 2);
                ctx.restore();

            } else if (config.type === 'trice' || config.type === 'stego' || config.type === 'ankylo') {
                // Quadr√∫pede
                ctx.fillStyle = accentColor;
                ctx.beginPath(); ctx.rect(-10 + walkCycle, -12, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(10 - walkCycle, -12, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(-10 - walkCycle, 6, 6, 6); ctx.fill();
                ctx.beginPath(); ctx.rect(10 + walkCycle, 6, 6, 6); ctx.fill();

                ctx.fillStyle = baseColor;
                ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-40 + walkCycle, 0);
                ctx.lineWidth = 6; ctx.strokeStyle = baseColor; ctx.stroke();
                
                if (config.type === 'ankylo') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.arc(-42 + walkCycle, 0, 6, 0, Math.PI*2); ctx.fill();
                }

                ctx.fillStyle = baseColor;
                ctx.beginPath(); ctx.ellipse(0, 0, 22, 14, 0, 0, Math.PI*2); ctx.fill();

                if (config.type === 'stego') {
                    ctx.fillStyle = accentColor;
                    for(let i=-15; i<15; i+=8) {
                        ctx.beginPath(); ctx.moveTo(i, -10); ctx.lineTo(i+4, -22); ctx.lineTo(i+8, -10); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(i, 10); ctx.lineTo(i+4, 22); ctx.lineTo(i+8, 10); ctx.fill();
                    }
                }
                if (config.type === 'ankylo') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.rect(-10, -8, 20, 16); ctx.fill();
                }

                ctx.fillStyle = baseColor;
                ctx.save();
                ctx.translate(24, 0);
                
                if (config.type === 'trice') {
                    ctx.fillStyle = accentColor;
                    ctx.beginPath(); ctx.arc(-2, 0, 12, -Math.PI/2, Math.PI/2); ctx.fill();
                    ctx.fillStyle = '#eee';
                    ctx.beginPath(); ctx.moveTo(4, -4); ctx.lineTo(18, -8); ctx.lineTo(6, -2); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(4, 4); ctx.lineTo(18, 8); ctx.lineTo(6, 2); ctx.fill();
                }
                
                ctx.fillStyle = baseColor;
                ctx.beginPath(); ctx.ellipse(0, 0, 10, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.restore();

            } else if (config.type === 'ptero') {
                // Voador
                const wingFlap = Math.sin(frame * 0.5) * 10;
                ctx.fillStyle = baseColor;
                
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, -30 + wingFlap); ctx.lineTo(20, -10); ctx.fill();
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, 30 - wingFlap); ctx.lineTo(20, 10); ctx.fill();

                ctx.beginPath(); ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(25, 0); ctx.lineWidth = 3; ctx.strokeStyle = accentColor; ctx.stroke();
            }

            ctx.restore();
        };

        // --- 4. GAME CANVAS ---
        
        const GameCanvas = ({ status, onGameOver, onWaveComplete, onScoreUpdate, initialScore, currentWave, upgrades }) => {
          const canvasRef = useRef(null);
          const grassPatternRef = useRef(null);
          const timerDisplayRef = useRef(null);
          
          const [keys, setKeys] = useState(new Set());
          const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
          const [isMouseDown, setIsMouseDown] = useState(false);
          const [activeSpecies, setActiveSpecies] = useState(new Set());

          const waveStartTimeRef = useRef(Date.now());
          const frameCountRef = useRef(0);
          
          const upgradeEffects = useMemo(() => ({
            speedBoost: upgrades.includes('engine') ? 1.25 : 1.0,
            damageBoost: upgrades.includes('damage') ? 1.4 : 1.0,
            fireRateBoost: upgrades.includes('fire_rate') ? 0.7 : 1.0,
            armorBoost: upgrades.includes('armor') ? 35 : 0,
            visionBoost: upgrades.includes('vision') ? 1.3 : 1.0,
            shieldBoost: upgrades.includes('shield') ? 0.75 : 1.0,
            autoRepair: upgrades.includes('auto_repair') ? 0.05 : 0,
            freezing: upgrades.includes('freezing'), // Novo efeito
            multishot: upgrades.includes('multishot') // Novo efeito
          }), [upgrades]);

          const speedModifier = useMemo(() => (1.0 + (initialScore / 10000) + (currentWave * 0.05)) * upgradeEffects.speedBoost, [initialScore, currentWave, upgradeEffects.speedBoost]);

          const tankRef = useRef({
            id: 'player',
            pos: { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 },
            radius: TANK_RADIUS,
            rotation: 0,
            turretRotation: 0,
            hp: 100,
            maxHp: 100,
            speed: BASE_TANK_SPEED,
            score: Math.floor(initialScore),
            ammo: 100,
            lastShot: 0,
          });

          const objectivePosRef = useRef({ x: 0, y: 0, isDiscovered: false });
          const obstaclesRef = useRef([]);
          const dinosRef = useRef([]);
          const projectilesRef = useRef([]);
          const bloodParticlesRef = useRef([]);
          const cameraRef = useRef({ x: 0, y: 0 });
          const frameIdRef = useRef(0);

          const minimapSize = 160;
          const minimapScale = minimapSize / WORLD_WIDTH;

          useEffect(() => {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 256; patternCanvas.height = 256;
            const pctx = patternCanvas.getContext('2d');
            if (pctx) {
              pctx.fillStyle = '#0f2d1a';
              pctx.fillRect(0, 0, 256, 256);
              for (let i = 0; i < 800; i++) {
                  pctx.fillStyle = Math.random() > 0.5 ? '#1a3d26' : '#0a1f12';
                  const s = Math.random() * 4;
                  pctx.fillRect(Math.random() * 256, Math.random() * 256, s, s);
              }
              for (let i = 0; i < 400; i++) {
                pctx.fillStyle = ['#225533', '#2d6640', '#1e442a'][Math.floor(Math.random() * 3)];
                pctx.beginPath();
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                pctx.moveTo(x, y);
                pctx.lineTo(x + 2, y - 4);
                pctx.lineTo(x + 4, y);
                pctx.fill();
              }
              const ctx = document.createElement('canvas').getContext('2d');
              if (ctx) grassPatternRef.current = ctx.createPattern(patternCanvas, 'repeat');
            }
          }, []);

          const checkCollision = useCallback((x, y, radius, obstacles, buffer = 0) => {
            const totalRadius = radius + buffer;
            for (const ob of obstacles) {
              const closestX = Math.max(ob.pos.x, Math.min(x, ob.pos.x + ob.width));
              const closestY = Math.max(ob.pos.y, Math.min(y, ob.pos.y + ob.height));
              const dist = Math.hypot(x - closestX, y - closestY);
              if (dist < totalRadius) return true;
            }
            return false;
          }, []);

          useEffect(() => {
            if (status === GameStatus.PLAYING) {
              waveStartTimeRef.current = Date.now();
              const tank = tankRef.current;
              tank.maxHp = 100 + upgradeEffects.armorBoost;
              tank.hp = tank.maxHp;
              tank.pos = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 };
              
              const obstacles = [];
              for (let i = 0; i < 12; i++) {
                const w = 150 + Math.random() * 250, h = 150 + Math.random() * 250;
                const pos = { x: 500 + Math.random() * (WORLD_WIDTH - 1000), y: 500 + Math.random() * (WORLD_HEIGHT - 1000) };
                if (Math.hypot(pos.x - WORLD_WIDTH/2, pos.y - WORLD_HEIGHT/2) > 600) {
                  obstacles.push({ pos, width: w, height: h, type: 'WALL', isDiscovered: true });
                }
              }
              obstaclesRef.current = obstacles;

              const margin = 250;
              const cornerPositions = [
                { x: margin, y: margin },
                { x: WORLD_WIDTH - margin, y: margin },
                { x: margin, y: WORLD_HEIGHT - margin },
                { x: WORLD_WIDTH - margin, y: WORLD_HEIGHT - margin }
              ];
              objectivePosRef.current = { ...cornerPositions[Math.floor(Math.random() * 4)], isDiscovered: true };

              const types = Object.keys(DINO_CONFIGS);
              const newDinos = [];
              let remainingDinos = Math.max(80, currentWave * 20);
              
              while (remainingDinos > 0) {
