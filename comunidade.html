<!-- ATUALIZA√á√ÉO DO CSS (Dentro de <style>) -->
<style>
    /* ... Mantenha as vari√°veis :root e estilos gerais anteriores ... */

    /* NOVA BARRA DE SUB-CATEGORIAS */
    .sub-category-bar {
        display: flex;
        gap: 10px;
        padding: 10px;
        overflow-x: auto;
        background: #fff;
        border-bottom: 1px solid #eee;
        flex-shrink: 0;
        scrollbar-width: none; /* Firefox */
    }
    .sub-category-bar::-webkit-scrollbar { display: none; } /* Chrome */

    .sub-cat-btn {
        min-width: 50px;
        height: 50px;
        border-radius: 12px;
        border: 2px solid #eee;
        background: #f9f9f9;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: all 0.2s;
        position: relative;
    }
    .sub-cat-btn:hover { background: #e0f7fa; }
    .sub-cat-btn.active {
        background: var(--bg);
        border-color: var(--primary);
        color: var(--primary);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(255, 87, 34, 0.2);
    }
    /* Label flutuante ao passar o mouse (opcional para UX) */
    .sub-cat-btn:hover::after {
        content: attr(data-label);
        position: absolute;
        bottom: -25px;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        font-size: 0.6rem;
        padding: 2px 6px;
        border-radius: 4px;
        white-space: nowrap;
        z-index: 100;
        pointer-events: none;
    }

    /* AJUSTE NA LISTA DE ITENS (Agora √© Grid, n√£o linhas horizontais) */
    .items-grid-area {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
        align-content: start;
    }
    
    /* ... Mantenha estilos de .item-card, .chat, etc ... */
</style>

<!-- ATUALIZA√á√ÉO DO HTML (Dentro de #view-custom) -->
<div id="view-custom" class="panel-view">
    <div class="panel-header" style="background:#FFF3E0; color:#E65100;">
        <span>üëï Customizar</span>
        <button class="close-panel-btn" onclick="switchPanel('chat')" style="color:#E65100; background:rgba(0,0,0,0.1);">‚úï</button>
    </div>
    
    <!-- Abas Principais -->
    <div class="inv-tabs">
        <button class="inv-tab-btn active" onclick="mudarAbaPrincipal('corpo')">üëï Corpo</button>
        <button class="inv-tab-btn" onclick="mudarAbaPrincipal('acessorios')">üëì Acess√≥rios</button>
    </div>

    <!-- Nova Barra de Sub-Categorias (√çcones) -->
    <div id="subCategoryBar" class="sub-category-bar">
        <!-- Preenchido via JS -->
    </div>

    <!-- √Årea de Itens (Grid em vez de linhas) -->
    <div id="customList" class="items-grid-area">
        <p style="text-align:center; color:#999; margin-top:20px;">Selecione uma categoria...</p>
    </div>
</div>

<!-- IN√çCIO DO SCRIPT (Vari√°veis Globais) -->
<script type="module">
    // ... (Imports do Firebase mantidos iguais) ...

    // --- CONFIGURA√á√ÉO DO AVATAR (Spread Zerado conforme solicitado) ---
    let AVATAR_CONFIG = { 
        scale: 0.22, 
        parts: {}, 
        offsets: { headY: -230, armY: -150, legY: 50, spreadX: 0, legSpread: 0 } // ZERADO
    };

    // Pe√ßas (Mantidas do seu c√≥digo original)
    AVATAR_CONFIG.parts = {
        "capa": { "x": 2, "y": -188, "pivX": 0.482, "pivY": 0.103 },
        "escudo_tras": { "x": -129, "y": -52, "pivX": 0.5, "pivY": 0.5 },
        "braco_tras": { "x": -55, "y": -188, "pivX": 0.85, "pivY": 0.094 },
        "perna_tras": { "x": -36, "y": 53, "pivX": 0.665, "pivY": 0.089 },
        "perna_frente": { "x": 47, "y": 54, "pivX": 0.604, "pivY": 0.072 },
        "tronco": { "x": -5, "y": -37, "pivX": 0.454, "pivY": 0.646 },
        "cintura": { "x": 46, "y": -33, "pivX": 0.386, "pivY": 0.336 },
        "cabeca": { "x": 1, "y": -300, "pivX": 0.482, "pivY": 0.809 },
        "rosto": { "x": -41, "y": -300, "pivX": 0.459, "pivY": 0.8 },
        "mascara": { "x": -5, "y": -300, "pivX": 0.5, "pivY": 0.5 },
        "cabelo": { "x": 1, "y": -300, "pivX": 0.482, "pivY": 0.699 },
        "arma_frente": { "x": 137, "y": 43, "pivX": 0.854, "pivY": 0.247 },
        "braco_frente": { "x": 95, "y": -192, "pivX": 0.117, "pivY": 0.024 },
        "escudo_frente": { "x": 153, "y": -12, "pivX": 0.5, "pivY": 0.5 }
    };

    const LAYER_ORDER = ['capa', 'escudo_tras', 'braco_tras', 'perna_tras', 'perna_frente', 'tronco', 'cintura', 'cabeca', 'rosto', 'mascara', 'cabelo', 'arma_frente', 'braco_frente', 'escudo_frente'];

    // --- KIT INICIAL (Apenas itens _padrao, nada pago) ---
    const STARTER_KIT = {
        'tronco': 'tronco_padrao.png', 
        'cabeca': 'cabeca_padrao.png', 
        'braco_frente': 'braco_frente_padrao.png', 
        'braco_tras': 'braco_tras_padrao.png', 
        'perna_frente': 'perna_frente_padrao.png', 
        'perna_tras': 'perna_tras_padrao.png', 
        'rosto': 'rosto_padrao.png'
        // Acess√≥rios removidos: Cabelo, Capa, M√°scara, Armas agora s√£o PAGOS/COMPR√ÅVEIS.
    };

    // --- DEFINI√á√ÉO DE CATEGORIAS E √çCONES ---
    const MENU_STRUCTURE = {
        'corpo': [
            { id: 'cabeca', icon: 'üôÇ', label: 'Cabe√ßa' },
            { id: 'rosto', icon: 'üëÄ', label: 'Rosto' },
            { id: 'tronco', icon: 'üëï', label: 'Tronco' },
            { id: 'braco_frente', icon: 'üí™', label: 'Bra√ßo F.' },
            { id: 'braco_tras', icon: 'ü§ú', label: 'Bra√ßo T.' },
            { id: 'perna_frente', icon: 'ü¶µ', label: 'Perna F.' },
            { id: 'perna_tras', icon: 'ü¶∂', label: 'Perna T.' }
        ],
        'acessorios': [
            { id: 'cabelo', icon: 'üíá', label: 'Cabelo' },
            { id: 'mascara', icon: 'üé≠', label: 'M√°scara' },
            { id: 'capa', icon: 'ü¶∏', label: 'Capa' },
            { id: 'cintura', icon: 'üéóÔ∏è', label: 'Cinto' },
            { id: 'arma_frente', icon: '‚öîÔ∏è', label: 'Arma' },
            { id: 'escudo_frente', icon: 'üõ°Ô∏è', label: 'Escudo F.' },
            { id: 'escudo_tras', icon: 'üê¢', label: 'Escudo T.' }
        ]
    };

    // Vari√°veis de Estado
    let currentTab = 'corpo'; // 'corpo' ou 'acessorios'
    let currentSubTab = 'cabeca'; // Categoria espec√≠fica selecionada

    let currentUser = null, myData = { fichas: 0 }, myOutfit = { ...STARTER_KIT };
    let previewOutfit = {}; 
    let shoppingCart = {}; 
    let storeItemsCache = [];
    let avatarImages = {};
    const BASE_ASSETS_URL = 'assets/avatar/';

   // --- L√ìGICA DE NAVEGA√á√ÉO DA LOJA ---

    // 1. Troca a Aba Principal (Corpo vs Acess√≥rios)
    window.mudarAbaPrincipal = function(tab) {
        currentTab = tab;
        
        // Define a primeira sub-categoria da lista como padr√£o ao trocar de aba
        currentSubTab = MENU_STRUCTURE[tab][0].id;
        
        renderSubCategoryBar();
        renderItemsGrid();
    }

    // 2. Troca a Sub-Categoria (Ao clicar no √≠cone)
    window.mudarSubCategoria = function(subCatId) {
        currentSubTab = subCatId;
        renderSubCategoryBar(); // Para atualizar o status 'active'
        renderItemsGrid();
    }

    // 3. Renderiza a Barra de √çcones
    function renderSubCategoryBar() {
        const bar = document.getElementById('subCategoryBar');
        bar.innerHTML = '';

        // Atualiza visual das abas principais
        const tabs = document.querySelectorAll('.inv-tab-btn');
        tabs[0].className = `inv-tab-btn ${currentTab === 'corpo' ? 'active' : ''}`;
        tabs[1].className = `inv-tab-btn ${currentTab === 'acessorios' ? 'active' : ''}`;

        // Gera os √≠cones
        const categories = MENU_STRUCTURE[currentTab];
        categories.forEach(cat => {
            const btn = document.createElement('div');
            btn.className = `sub-cat-btn ${currentSubTab === cat.id ? 'active' : ''}`;
            btn.innerHTML = cat.icon;
            btn.setAttribute('data-label', cat.label); // Tooltip CSS
            btn.onclick = () => mudarSubCategoria(cat.id);
            bar.appendChild(btn);
        });
    }

    // 4. Renderiza a Grade de Itens (Apenas da Sub-Categoria atual)
    function renderItemsGrid() {
        const container = document.getElementById('customList');
        container.innerHTML = '';

        const cat = currentSubTab; // Ex: 'cabeca' ou 'espada'
        let itemsToShow = [];

        // --- A. Item Padr√£o (Se existir para esta categoria) ---
        // Apenas categorias de CORPO t√™m itens padr√£o no Starter Kit agora.
        if (STARTER_KIT[cat]) {
            itemsToShow.push({ id: STARTER_KIT[cat], nome: "Padr√£o", preco: 0, isDefault: true });
        }

        // --- B. Meus Itens (Invent√°rio) ---
        // Filtra itens que o usu√°rio j√° comprou para esta categoria
        const myItems = (myData.inventario || []).filter(i => i.includes(cat) && i !== STARTER_KIT[cat]);
        myItems.forEach(i => itemsToShow.push({ id: i, nome: formatName(i, cat), preco: 0, isOwned: true }));

        // --- C. Loja (Itens √† venda) ---
        // Pega do cache global carregado do Firebase
        const shopItems = storeItemsCache.filter(i => i.categoria === cat && !myItems.includes(i.id));
        shopItems.forEach(i => itemsToShow.push(i));

        if (itemsToShow.length === 0) {
            container.innerHTML = '<p style="width:100%; text-align:center; color:#999;">Nenhum item dispon√≠vel aqui.</p>';
            return;
        }

        // Renderiza os Cards
        itemsToShow.forEach(item => {
            const isWearing = previewOutfit[cat] === item.id;
            const inCart = shoppingCart[cat] && shoppingCart[cat].id === item.id;
            const owned = item.isDefault || item.isOwned;

            const card = document.createElement('div');
            card.className = `item-card ${isWearing ? (inCart ? 'previewing' : 'equipped') : (owned ? 'owned' : '')}`;
            
            // Labels de Pre√ßo
            let label = "";
            if (item.isDefault) label = `<span class="tag tag-free">GR√ÅTIS</span>`;
            else if (item.isOwned) label = `<span class="tag tag-owned">ITEM</span>`;
            else label = `<span class="tag tag-price">ü™ô ${item.preco}</span>`;

            // Nome formatado
            let displayName = item.nome || formatName(item.id, cat);

            card.innerHTML = `
                <img src="${BASE_ASSETS_URL}${cat}/${item.id}" loading="lazy">
                <div class="item-name">${displayName}</div>
                ${label}
                ${isWearing ? '<div class="check-icon">‚úî</div>' : ''}
            `;
            
            // Clique
            card.onclick = () => toggleItem(cat, item, owned, item.isDefault);
            container.appendChild(card);
        });
    }

    // Auxiliar para limpar nomes de arquivo
    function formatName(id, cat) {
        return id.replace('.png','').replace('_padrao','').replace(cat+'_','').slice(0, 10);
    }

    // 5. L√≥gica de Vestir/Despir (Atualizada com regras de Obrigat√≥rio vs Opcional)
    window.toggleItem = function(cat, itemObj, isOwned, isDefault) {
        const isWearing = previewOutfit[cat] === itemObj.id;
        
        // Verifica se √© categoria obrigat√≥ria (Corpo) ou opcional (Acess√≥rios)
        // Usamos a chave do MENU_STRUCTURE para saber onde a categoria est√°
        const isBodyPart = MENU_STRUCTURE['corpo'].some(c => c.id === cat);

        if (isWearing) {
            if (isBodyPart) {
                // REGRA: N√£o pode ficar pelado (Corpo). 
                // Se clicar no que j√° est√° usando, n√£o faz nada (ou avisa).
                // O usu√°rio s√≥ pode TROCAR por outro, n√£o remover.
                return; 
            } else {
                // Acess√≥rios podem ser removidos
                previewOutfit[cat] = null;
                if (shoppingCart[cat]) delete shoppingCart[cat];
            }
        } else {
            // Equipar novo item
            previewOutfit[cat] = itemObj.id;
            
            if (isOwned || isDefault) {
                // Se j√° tenho, remove do carrinho se estava l√°
                if (shoppingCart[cat]) delete shoppingCart[cat];
            } else {
                // Se n√£o tenho, adiciona ao carrinho
                shoppingCart[cat] = itemObj;
            }
        }

        updateUI(); // Atualiza bot√µes e avatar
        renderItemsGrid(); // Atualiza bordas dos cards
    }

    // --- INTEGRA√á√ÉO COM SISTEMA DE PAIN√âIS ---
    
    // Atualize a fun√ß√£o switchPanel para chamar a renderiza√ß√£o correta
    window.switchPanel = function(id) {
        // Reset preview se sair do custom
        if(document.getElementById('view-custom').classList.contains('active') && id !== 'custom') {
            resetPreview(); 
        }
        
        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        if(id === 'chat') document.getElementById('btnChat').classList.add('active');
        if(id === 'custom') document.getElementById('btnCustomize').classList.add('active'); 

        document.querySelectorAll('.panel-view').forEach(p => p.classList.remove('active'));
        document.getElementById('view-' + id).classList.add('active');

        if(id === 'custom') {
            // Inicializa a loja na primeira aba e sub-aba
            mudarAbaPrincipal(currentTab); 
        }
        
        setTimeout(resizeCanvas, 100);
    }
// --- TRANSA√á√ïES (COMPRA E SALVAMENTO) ---

    window.finalizarCompra = async function() {
        if (!currentUser) return alert("Voc√™ precisa estar logado!");
        
        // Recalcula custo total do carrinho
        let custo = 0;
        let itensComprados = [];
        
        for(let key in shoppingCart) {
            custo += shoppingCart[key].preco;
            itensComprados.push(shoppingCart[key].id);
        }
        
        if (itensComprados.length === 0) return;

        if (myData.fichas < custo) return alert(`Fichas insuficientes! Voc√™ precisa de ${custo} mas tem ${myData.fichas}.`);
        
        if (!confirm(`Confirmar compra de ${itensComprados.length} itens por ${custo} Fichas?`)) return;

        try {
            const userRef = doc(db, "users", currentUser.uid);
            
            // Atualiza√ß√£o At√¥mica no Firebase
            await updateDoc(userRef, { 
                fichas: increment(-custo), 
                inventario: arrayUnion(...itensComprados),
                avatar_equipado: previewOutfit // J√° salva o look equipado
            });
            
            // Atualiza estado local
            myData.fichas -= custo;
            if(!myData.inventario) myData.inventario = [];
            myData.inventario.push(...itensComprados);
            
            // Torna o outfit oficial
            myOutfit = { ...previewOutfit }; 
            
            // Atualiza UI
            document.getElementById('coinDisplay').innerText = `ü™ô ${myData.fichas}`;
            shoppingCart = {}; // Limpa carrinho
            
            alert("Sucesso! Compra realizada.");
            updateUI();
            renderItemsGrid(); // Atualiza os √≠cones de "owned" na loja
            
        } catch(e) { 
            console.error(e); 
            alert("Erro na compra. Verifique sua conex√£o."); 
        }
    }

    window.salvarOutfitNoBanco = async function() {
        if(!currentUser) return;
        try {
            await updateDoc(doc(db, "users", currentUser.uid), { avatar_equipado: previewOutfit });
            myOutfit = { ...previewOutfit };
            shoppingCart = {}; // Garante que carrinho esteja vazio ao salvar
            updateUI();
            alert("Look salvo com sucesso!");
        } catch(e) {
            console.error(e);
        }
    }

    // --- ENGINE GR√ÅFICA & AVATAR ---
    
    const canvas = document.getElementById('arcadeCanvas');
    const container = document.getElementById('canvasContainer');
    const ctx = canvas.getContext('2d');
    let avatares = []; 
    let lastTime = 0; 
    let initCalled = false;

    // Carrega imagens baseado no outfit atual (Preview ou Oficial)
    function carregarImagens() {
        LAYER_ORDER.forEach(layer => {
            // Prioridade: Preview > Outfit Salvo > Starter Kit
            // Se for nulo (ex: acess√≥rio removido), n√£o carrega nada.
            const itemFile = previewOutfit[layer] || myOutfit[layer] || STARTER_KIT[layer]; 
            
            if(itemFile) {
                const key = `${layer}/${itemFile}`;
                if(!avatarImages[key]) {
                    const img = new Image(); 
                    img.src = `${BASE_ASSETS_URL}${key}`;
                    // Tenta iniciar a engine assim que o tronco carregar (pe√ßa central)
                    img.onload = () => { if(layer==='tronco') initEngine(); };
                    img.onerror = () => { 
                        console.warn(`Falha ao carregar: ${key}`);
                        img.isBroken = true; 
                        if(layer==='tronco') initEngine(); 
                    };
                    avatarImages[key] = img;
                }
            }
        });
        // Fallback de seguran√ßa para iniciar se imagens j√° estiverem em cache
        setTimeout(() => { if(!initCalled) initEngine(); }, 500);
    }

    function initEngine() {
        if(initCalled) return; 
        initCalled = true;
        
        resizeCanvas(); 
        window.addEventListener('resize', resizeCanvas);
        
        // Cria o Avatar do Jogador ("Eu")
        const me = new Avatar("Eu", true); 
        me.outfit = previewOutfit; // Vincula ao objeto din√¢mico de preview
        avatares.push(me);
        
        requestAnimationFrame(gameLoop);
    }

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1; 
        const rect = container.getBoundingClientRect();
        if(rect.width === 0) return;
        
        canvas.width = rect.width * dpr; 
        canvas.height = rect.height * dpr;
        
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.scale(dpr, dpr);
        
        const chaoY = rect.height - 80; 
        avatares.forEach(a => { 
            a.y = chaoY; 
            if(a.x === 0) a.x = rect.width/2; 
        });
    }

    function gameLoop(t) {
        const dt = (t-lastTime)/1000; 
        lastTime = t;
        
        const w = canvas.clientWidth; 
        const h = canvas.clientHeight;
        
        // Limpa tela
        ctx.clearRect(0,0,w,h);
        
        // Desenha Ch√£o (Elipse simples)
        ctx.fillStyle = '#81C784'; 
        ctx.beginPath(); 
        ctx.ellipse(w/2, h+60, w*0.9, 100, 0, 0, Math.PI*2); 
        ctx.fill();
        ctx.strokeStyle = '#4CAF50'; 
        ctx.lineWidth = 10; 
        ctx.stroke();
        
        // Sincroniza outfit do player em tempo real com o preview
        if(avatares.length > 0 && avatares[0].isMe) {
            avatares[0].outfit = previewOutfit;
        }

        // Ordena por Y para profundidade (quem est√° mais embaixo desenha na frente)
        avatares.sort((a,b)=>a.y - b.y);
        
        // Atualiza e Desenha
        avatares.forEach(a => { 
            a.update(dt); 
            a.draw(ctx); 
        });
        
        requestAnimationFrame(gameLoop);
    }

    // CLASSE AVATAR
    class Avatar {
        constructor(nome, isMe=false) {
            this.nome = nome; 
            this.isMe = isMe; 
            // Se for bot, usa o Starter Kit (sem acess√≥rios pagos)
            this.outfit = isMe ? previewOutfit : { ...STARTER_KIT };
            
            this.x = container.clientWidth/2; 
            this.y = container.clientHeight-80; 
            this.dir = 1; 
            this.speed = 40; 
            this.state='idle'; 
            this.targetX = this.x; 
            
            // IA simples para bots andarem
            if(!isMe) setTimeout(()=>this.iaLoop(), 1000);
        }

        falar(txt) { this.msg = txt; this.msgTimer = 300; }

        iaLoop() {
            const w = canvas.clientWidth;
            this.targetX = Math.random() * (w - 60) + 30; 
            this.dir = this.targetX > this.x ? 1 : -1; 
            this.state='walk';
            
            // Anda por um tempo, depois para
            setTimeout(()=>{ 
                this.state='idle'; 
                setTimeout(()=>this.iaLoop(), 3000 + Math.random()*2000); 
            }, 3000);
        }

        update(dt) {
            // Limites da tela
            if(this.x < 20) { this.x = 20; this.dir = 1; }
            if(this.x > canvas.clientWidth-20) { this.x = canvas.clientWidth-20; this.dir = -1; }
            
            this.timer = (this.timer||0) + dt*5; 
            
            // Timer do bal√£o de fala
            if(this.msgTimer>0) this.msgTimer--; else this.msg="";
            
            // Movimento
            if(this.state==='walk') { 
                this.x += this.dir * (this.speed * dt); 
                if(Math.abs(this.x - this.targetX) < 5) this.state='idle'; 
            }
        }

        draw(ctx) {
            const s = AVATAR_CONFIG.scale; 
            let walk=0, bob=0, br=Math.sin(this.timer*0.5)*0.05;
            
            if(this.state==='walk') { 
                walk=Math.sin(this.timer); 
                bob=Math.abs(walk)*10; 
            }
            
            ctx.save(); 
            ctx.translate(this.x, this.y);
            
            // Nome
            ctx.fillStyle = this.isMe?'#FFC107':'white'; 
            ctx.font="bold 12px Nunito"; 
            ctx.textAlign="center"; 
            ctx.shadowColor='rgba(0,0,0,0.5)'; 
            ctx.shadowBlur=4; 
            ctx.fillText(this.nome, 0, -160*s); 
            ctx.shadowBlur=0;
            
            if(this.msg) this.drawBubble(ctx, s);
            
            // Espelhamento horizontal baseada na dire√ß√£o
            ctx.scale(-this.dir, 1);
            
            // Desenha Camadas
            LAYER_ORDER.forEach(cat => {
                const file = this.outfit[cat]; 
                if(!file) return; // Se n√£o tiver item (ex: sem capa), pula
                
                const key = `${cat}/${file}`;
                const img = avatarImages[key]; 
                
                if(!img || !img.complete || img.isBroken) return;
                
                const p = AVATAR_CONFIG.parts[cat] || {x:0,y:0,pivX:0.5,pivY:0.5};
                let ax=0, ay=-bob, ar=0;

                // L√≥gica de Parentesco (Armas seguem m√£os)
                if(cat.includes('arma') || cat.includes('escudo')) {
                    const pName = cat.includes('frente') ? 'braco_frente' : 'braco_tras';
                    const parent = AVATAR_CONFIG.parts[pName];
                    const armRot = (cat.includes('frente') ? -walk : walk) * 0.6;
                    
                    const dx = (p.x - parent.x)*s; 
                    const dy = (p.y - parent.y)*s;
                    
                    // Rotaciona o item junto com o bra√ßo
                    const rx = dx*Math.cos(armRot) - dy*Math.sin(armRot); 
                    const ry = dx*Math.sin(armRot) + dy*Math.cos(armRot);
                    
                    this.drawImg(ctx, img, (parent.x*s)+rx, (parent.y*s)-bob*s+ry, armRot, p, s, cat); 
                    return;
                }

                // Anima√ß√£o de Membros
                if(cat.includes('perna')) {
                    const isF=cat.includes('frente'); 
                    ay=-bob; 
                    ar=(isF?walk:-walk)*0.5;
                    // Spread agora √© 0 conforme solicitado, mas mantemos a vari√°vel caso mude no futuro
                    ax = isF ? -AVATAR_CONFIG.offsets.legSpread : AVATAR_CONFIG.offsets.legSpread;
                } else if(cat.includes('braco')) {
                    const isF=cat.includes('frente'); 
                    ay=-bob; 
                    ar=(isF?-walk:walk)*0.6;
                    ax = isF ? -AVATAR_CONFIG.offsets.spreadX : AVATAR_CONFIG.offsets.spreadX;
                } else if(['cabeca','rosto','mascara','cabelo'].includes(cat)) { 
                    ay = -bob + (br*5); // Respira√ß√£o
                    ar = br*0.2; 
                }
                
                this.drawImg(ctx, img, (p.x*s)+(ax*s), (p.y*s)+(ay*s), ar, p, s, cat);
            });
            
            ctx.restore();
        }

        drawImg(ctx, img, x, y, r, p, s, n) {
            ctx.save(); 
            ctx.translate(x, y); 
            ctx.rotate(r);
            // Escurece partes de tr√°s para dar profundidade
            if(n.includes('tras')||n==='capa') ctx.filter="brightness(0.85)";
            ctx.drawImage(img, -img.width*s*p.pivX, -img.height*s*p.pivY, img.width*s, img.height*s);
            ctx.filter="none"; 
            ctx.restore();
        }

        drawBubble(ctx, s) {
            ctx.save(); 
            ctx.translate(0, -190*s); 
            const w = ctx.measureText(this.msg).width + 20;
            ctx.fillStyle="white"; 
            ctx.beginPath(); 
            ctx.roundRect(-w/2, -25, w, 25, 10); 
            ctx.fill();
            ctx.beginPath(); 
            ctx.moveTo(0,0); 
            ctx.lineTo(-5,5); 
            ctx.lineTo(5,5); 
            ctx.fill();
            ctx.fillStyle="#333"; 
            ctx.fillText(this.msg, 0, -8);
            ctx.restore();
        }
    }

    // --- CHAT & UTILIT√ÅRIOS ---
    
    const btnSend = document.getElementById('btnSend');
    const ipt = document.getElementById('msgInput');
    
    function sendMsg() {
        if(!ipt.value.trim()) return;
        const h = document.getElementById('chatHistory');
        h.innerHTML += `<div class="msg me"><strong>Eu</strong>${ipt.value}</div>`;
        h.scrollTop = h.scrollHeight;
        if(avatares.length>0) avatares[0].falar(ipt.value);
        ipt.value = "";
    }
    
    btnSend.onclick = sendMsg; 
    ipt.onkeypress = e => e.key==='Enter' && sendMsg();

    window.spawnarAvatarTeste = () => {
        const bot = new Avatar("Bot " + Math.floor(Math.random()*100));
        avatares.push(bot);
        document.getElementById('online-count').innerText = avatares.length;
    };

    // Inicia o sistema
    bootSystem();

</script>
</body>
</html>
    // ... (Mantenha o restante do c√≥digo: finalizarCompra, salvarOutfitNoBanco, Engine Gr√°fica, etc.) ...
</script>
